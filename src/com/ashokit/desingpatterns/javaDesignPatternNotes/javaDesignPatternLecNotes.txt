############################
‚ùÑÔ∏è Factory Design Pattern 
############################
‚û§ The factory design pattern says that define an interface (A java interface or an abstract class) and let the subclasses decide which object to instantiate. The factory method in the interface lets a class defer the instantiation to one or more concrete subclass 
‚û§ In factory pattern , we create objects without exposing the creation logic to the client and the client uses the same common interface to create a new type of object 
‚û§ In factory pattern , we create object without exposing the creation logic to the client and refer to newly created object using a common interface 
‚û§ A factory pattern of factory method pattern says that just define an interface or abstract class for creating an object but let the subclass decide which class to instantiate. 

‚û§ A factory pattern or factory method pattern says that just define an interface or abstract class for creating an object but let the subclasses decide which class to instantiate  
‚û§ The factory method pattern is also known as virtual constructor.

Example: 
----------
package com.ashokit.desingpatterns;

public class FactoryPatternExample {

	public static void main(String[] args) {
		Factory f = new Factory();
		Notification n = f.createNotification("SMS");
		n.notifi();
		Notification n1 = f.createNotification("Email");
		n1.notifi();
	}
}

interface Notification{
	public void notifi();
}

class SMSNotification implements Notification {
	
	@Override
	public void notifi() {
		System.out.println("Triggering notification through SMS");
	}
}

class EmailNotification implements Notification {
	
	@Override
	public void notifi() {
		System.out.println("Triggering notification through Email");
	}
}

class Factory {
	public Notification createNotification(String mode) {
		
		if(mode.equalsIgnoreCase("SMS")) {
			Notification n = new SMSNotification();
			return n;
		}
		if(mode.equalsIgnoreCase("Email")) {
			Notification n = new EmailNotification();
			return n;
		}
		return null;
	}
}

############################
‚ùÑÔ∏è Chain of responsibility 
############################
‚û§ Chain of responsibilty as a design pattern consisting of a source of command objects and a series of processing objects 
üëâ What problems can the chain of responsibility design pattern solves? 
‚û§ Coupling the sender of a request to its receiver should be avoided 
‚û§ It should be possible that more than one receiver can handle a request 

‚û§ In the java world we benefit from chain of responsibility every day . One such classic example is servlet filters in java that allows multiple filters to process an http request. Though in that case each filter invokes the chain instead of the next filter .

public class CustomFilter implements Filter{
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException{
		//process the request 
		//pass the request(ie; the command)along the filter chain 
		chain.doFilter(request,response);
	}
}
// Filter is something in servlets which gets executed before the controller.If the provided credentials are correct then it will send the request to the controller else it will guide you back to the UI.

Example: 
---------
package com.ashokit.desingpatterns.chainofresponsibility;

import java.util.Scanner;

public class ChainOfResATMExamp {

	DispenceChain d;
	ChainOfResATMExamp() {
	
		this.d=new Notes2000Rack();
		DispenceChain d1 = new Notes500Rack();
		DispenceChain d2 = new Notes100Rack();
		d.chain(d1);
		d1.chain(d2);
	}
	
	public static void main(String[] args) {
		
		ChainOfResATMExamp c = new ChainOfResATMExamp();
		while(true) {
			System.out.println("Please enter the amount to be withdrawn");
			Scanner s = new Scanner(System.in);
			int amount = s.nextInt();
			if(amount!=0) {
				if(amount % 100 != 0) {
					System.out.println("Please enter multiples of 100");
					return;
				}else {
					c.d.dispence(new Currency(amount));
				}
			}
		}
	}
}

class Currency{
	private int amount;
	
	Currency(int amt){
		this.amount = amt;
	}

	public int getAmount() {
		return amount;
	}

	public void setAmount(int amount) {
		this.amount = amount;
	}
	
}

interface DispenceChain{
	void dispence(Currency current);
	void chain(DispenceChain d);
}

class Notes2000Rack implements DispenceChain{

	DispenceChain chain;
	
	@Override
	public void dispence(Currency current) {
		// TODO Auto-generated method stub
		int noOf2000Notes = current.getAmount()/2000;
		System.out.println("Dispencing " +noOf2000Notes +" 2000 notes ");
		int remainder = current.getAmount()%2000;
		if(remainder != 0) {
			chain.dispence(new Currency(remainder));
		}
		
	}

	@Override
	public void chain(DispenceChain chain) {
		// TODO Auto-generated method stub
		this.chain=chain;
	}
	
}

class Notes500Rack implements DispenceChain{

	DispenceChain chain;
	
	@Override
	public void dispence(Currency current) {
		// TODO Auto-generated method stub
		int noOf500Notes = current.getAmount()/500;
		System.out.println("Dispencing " +noOf500Notes +" 500 notes ");
		int remainder = current.getAmount()%500;
		if(remainder != 0) {
			chain.dispence(new Currency(remainder));
		}
		
	}

	@Override
	public void chain(DispenceChain chain) {
		// TODO Auto-generated method stub
		this.chain=chain;
	}
	
}

class Notes100Rack implements DispenceChain{

	DispenceChain chain;
	
	@Override
	public void dispence(Currency current) {
		// TODO Auto-generated method stub
		int noOf100Notes = current.getAmount()/100;
		System.out.println("Dispencing " +noOf100Notes +" 100 notes ");
		int remainder = current.getAmount()%100;
		if(remainder != 0) {
			chain.dispence(new Currency(remainder));
		}
		
	}

	@Override
	public void chain(DispenceChain chain) {
		// TODO Auto-generated method stub
		this.chain=chain;  
	}
	
}

###########################
‚ùÑÔ∏è Builder Design Pattern 
###########################
‚û§  The builder pattern is a design pattern designed to provide a flexible solution to various object creation problems in OOPS. The intent of the builder design pattern is to separate the construction of a complex object from its representation 
‚û§ It is used to construct a complex object step by step and the final step will return the object. The process of constructing an object should be generic so that it can be used to create different representations of the same object 

‚û§ Thus, there are two specific problems that we need to solve: 
	=> Too many constructor arguments 
	=> Incorrect object state.

üëâ Advantages of builder design pattern 
=========================================
‚û§ The parameters to the constructor are reduced and are provided in highly readable method calls .
‚û§ Builder design pattern also helps in minmizing the number of parameters in the constructor and thus there is no need to pass in null for optional parameters to the constructor
‚û§ Object is always instantiated in a complete state.
‚û§ Immutable objects can be built without much complex logic in the object building process.

‚ú® When to use builder pattern ?
*********************************
‚û§ If you find yourself in a situation where you keep on adding new parameters to a constructor resulting in code that becomes error-prone and hard to read perhaps its a good time to take a step back and consider refactoring your code to use a builder 
‚û§ Look at the user class and user builder class which we created in the class to implement builder design pattern. User class can have many user attributes, like first name, last name, email, mobile, address and in future we can have more. If we create the constructor with these fields if the field is optional then we have to pass null and every time we should be concious while creating the object, we may pass address in place of email if we mistaken.
‚û§ To avoid all these issues instead of calling the constructor we can create the method and call these methods to create the object. So complex object can be easily developed with this approach 
‚û§ We created user builder inner class and added all the attributes using the methods and created the user object.

Example: 
---------
package com.ashokit.desingpatterns.builderdesignpattern;

public class UserWithBuilderPattern {
	
	
	
	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return "FirstName: "+firstName+ " LastName: "+lastName;
	}

	UserWithBuilderPattern(UserBuilder ub){
		this.firstName = ub.firstName;
		this.lastName = ub.lastName;
		this.age = ub.age;
		this.mobile = ub.mobile;
	}

	private String firstName;//required
	private String lastName;//required
	private int age;//not required
	private long mobile;//not required
	
	public String getFirstName() {
		return firstName;
	}
	
	public String getLastName() {
		return lastName;
	}
	
	public int getAge() {
		return age;
	}
	
	public long getMobile() {
		return mobile;
	}	
	
	static class UserBuilder{
		
		private String firstName;
		private String lastName;
		private int age;
		private long mobile;
		
		public UserBuilder(String firstName, String lastName) {
			this.firstName = firstName;
			this.lastName = lastName;
		}
		
		public UserBuilder age(int age) {
			this.age = age;
			return this;
		}
		
		public UserBuilder mobile(long mobile) {
			this.mobile = mobile;
			return this;
		}
		
		// using the build() we will convert the UserBuilder object to UserWithBuilderPattern object
		UserWithBuilderPattern build() {
			UserWithBuilderPattern u = new UserWithBuilderPattern(this);
			return u;
		}

	
	}
	
	public static void main(String[] args) {
		//Now suppose here we want to create an object with all the fields 
		UserWithBuilderPattern u = new UserWithBuilderPattern.UserBuilder("Deepak", "Yadav").age(24).mobile(80906337).build();
		System.out.println(u);
		//Now for fn,ln
		UserWithBuilderPattern u1 = new UserWithBuilderPattern.UserBuilder("Viper", "Ankur").build();
		System.out.println(u1);
		// fn, ln, age
		UserWithBuilderPattern u2 = new UserWithBuilderPattern.UserBuilder("Suraj","Yadav").age(22).build();
		System.out.println(u2);
		//So hence like this using the builder design pattern we have solved the problem of object creation.
	}

}
/*
 * So what we will do is we will create an object for the required fields 
 * Then we will add the optional field that is provided to that object
 * Eg: firtName and lastName are the required fields so we will create object using these fields 
 * (fn,ln).add(age).add(mobile).build() //like this if user provides age and mobile number then we add it.
 * So this is how we create an object using the builder design pattern.
 * 
 * ## How do we do this ? 
 * -> So we will create an inner class in which i will declare the constructor with the required fileds
 */

##############################
‚ùÑÔ∏è Decorator Design Pattern
##############################
‚û§ The decorator pattern is a design pattern that allows behaviour to be added to an individual object dynamically wihthout affecting the behaviour of other objects within the same class .The decorator pattern is often useful for adhering to the single responsibility principle as it allows funtionality to be divided between classes with unique areas of concern . Decorator pattern allow a user to add new functionality to an existing object without altering its structure so there is no change to the original class 
‚û§ Decorator desing pattern create decorator classes which wrap the original class and supply additional functionality by keeping the class methods signature unchanged 
‚û§ Decorator desing pattern are most frequently used for applying single responsibility principles since we divide the functionality into classes with unique areas of concern 
‚û§ Decorator design pattern is useful in providing runtime modification abilities and hence more flexible . Its easy to maintain and extend when the amount of choices are more. 
‚û§ Decorator pattern is used a lot in Java IO classes like FileReader , BufferedReader etc.

Example: 
--------
package com.ashokit.desingpatterns.decorateddesignpattern;

public class DecoratorPatternExample {

	public static void main(String[] args) {
		BasicPlan kartikPolicy = new BasePolicy();
		System.out.println(kartikPolicy.getPremium());
		System.out.println(kartikPolicy.policyDetails());
		
		BasicPlan surajPolicy = new BasePolicy();
		System.out.println(surajPolicy.getPremium());
		System.out.println(surajPolicy.policyDetails());
		
		//Suppose Suraj doesn't want to take the same policy he wants to add some more things to this base policy 
		//If we add anything in the BasePolicy class then it will affect every other object of the class  so for doing this we will be using decorator design pattern
		
		surajPolicy = new AccidentalBenefit(surajPolicy);
		System.out.println(surajPolicy.getPremium());
		System.out.println(surajPolicy.policyDetails());
		
		surajPolicy = new CriticalBenefit(surajPolicy);
		System.out.println(surajPolicy.getPremium());
		System.out.println(surajPolicy.policyDetails());
		
		//So like this here by using AccidentalBenefit class i am able to modify the behaviour of the single object of the class without affecting the another objects.
	}
}

interface BasicPlan{
	int getPremium();
	String policyDetails();
}

class BasePolicy implements BasicPlan{

	@Override
	public int getPremium() {
		// TODO Auto-generated method stub
		return 1566;
	}

	@Override
	public String policyDetails() {
		// TODO Auto-generated method stub
		return "This is a basic plan";
	}
	
}

abstract class PolicyDecorator implements BasicPlan{
	BasicPlan basicPlan;
	
	PolicyDecorator(BasicPlan basicPlan){
		this.basicPlan = basicPlan;
	}

	@Override
	public int getPremium() {
		// TODO Auto-generated method stub
		return basicPlan.getPremium();
	}

	@Override
	public String policyDetails() {
		// TODO Auto-generated method stub
		return basicPlan.policyDetails();
	}
		
}

class AccidentalBenefit extends PolicyDecorator{
	
	AccidentalBenefit(BasicPlan basicPlan){
		super(basicPlan);
	}

	@Override
	public int getPremium() {
		// TODO Auto-generated method stub
		return super.getPremium()+58;
	}

	@Override
	public String policyDetails() {
		// TODO Auto-generated method stub
		return super.policyDetails()+" Accidental Cover is provided ";
	}	
	
}

class CriticalBenefit extends PolicyDecorator{
	
	CriticalBenefit(BasicPlan basicPlan){
		super(basicPlan);
	}

	@Override
	public int getPremium() {
		// TODO Auto-generated method stub
		return super.getPremium()+650;
	}

	@Override
	public String policyDetails() {
		// TODO Auto-generated method stub
		return super.policyDetails()+"and Critical Cover is provided ";
	}	
	
}
/*
 * So for doing this we will write another class decorator which will implement the BasicPlan interface
 * Using that class we will create another class called AccidentalBenefit  
*/

############################
‚ùÑÔ∏è Adapter Desing Pattern 
############################
‚û§ The adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface 
‚û§ It is often used to make existing classes work with others without modifying their source code 

üåü Simple definition in other words 
=====================================
‚û§ The adapter design pattern is a structural desing pattern that allows two unrelated/uncommon interfaces to work together. In other words the adapter pattern makes two incompatible interfaces compatible without changing their existing code.
‚û§ Adapter patterns use a single class(the adapter class) to join functioinalities of independent or incompatible interfaces/classes.
‚û§ The adapter pattern is a structural design pattern that acts as a bridge between two interfaces that are incompatible . The term adapter is used to represent an object that enables two mutually incompatible interfaces to communicate and collaborate

Example: 
---------
package com.ashokit.desingpatterns.adapterdesignpattern;

public class AdapterDesignPatternExample {

	public static void main(String[] args) {
		AshokIt as = new AshokIt();
		as.setPaymentType("UPI");
	    as.setDetails("12346789");
	    
	    Paytm paytm = PaymentAdapter.ConvertBillDeskToPaytm(as);
	}
	
}

interface BillDesk{
	void setPaymentType(String paymentType);
	String getPaymentType();
	void setDetails(String data);
	String getDetails();
}

interface Paytm {
	void setTypeOfPayment(String paymentType);
	String getTypeOfPayment();
	void provideDetails(String data);
	String getDetails(); 
}

class PaymentAdapter implements BillDesk{
	static Paytm p = null;
	
	PaymentAdapter(Paytm p){
		this.p = p;
	}

	@Override
	public void setPaymentType(String paymentType) {
		// TODO Auto-generated method stub
		
	}
	
	static Paytm ConvertBillDeskToPaytm(BillDesk b){
		p.setTypeOfPayment(b.getPaymentType());
		p.provideDetails(b.getDetails());
		return p;
	}

	@Override
	public String getPaymentType() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setDetails(String data) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getDetails() {
		// TODO Auto-generated method stub
		return null;
	}
}

class AshokIt implements BillDesk{

	String PaymentType = null;
	String data = null;
	@Override
	public void setPaymentType(String paymentType) {
		// TODO Auto-generated method stub
		this.PaymentType = paymentType;
	}

	@Override
	public String getPaymentType() {
		// TODO Auto-generated method stub
		return PaymentType;
	}

	@Override
	public void setDetails(String data) {
		// TODO Auto-generated method stub
		this.data = data;
	}

	@Override
	public String getDetails() {
		// TODO Auto-generated method stub
		return data;
	}	
}

############################
‚ùÑÔ∏è Iterator Design Pattern
############################
‚û§ Collections are one of the most used data types in programming nonetheless, a collection is just a container for a group of objects 
‚û§ Most collections store their elements in simple lists. However some of them are based on stacks, trees, graphs and other complex data structures. 
‚û§ But no matter how a collection is structured, it must provide some way of accessing its elemnts so that other code can use these elements. There should be a way to go through each element of the collection without accessing the same elements over and over 
‚û§ The main idea of the iterator pattern is to extract the traversal behaviour of a collection into a separate object called an iterator.
‚û§ In addition to implementing the algo itself an iterator object encapsulates all of the traversal details, such as the current position and how many elements are left till the end. Because of this several iterators can go through the same collection at the same time, independently of each others
‚û§ Usually iterators provide one primary method for fetching elements of the collection . The client can keep running this method until it doesnt return anything which means that the iterator has traversed all of the elements.

#############################
‚ùÑÔ∏è Observer Design Pattern 
#############################
‚û§ It is a behavioural design pattern . It specifies communication between objects observable and observers. An observable is an object which notifies observers about the changes in its state.
‚û§ The observer design pattern is a software design pattern in which an object named the subject maintains a list of its dependents called observers, and notifies them automatically of any state changes usually by calling one of their methods .
‚û§ It is mainly used for implementing distributed event handling systems 
‚û§ In simple words if we take the example of twitter if 100 users are following modi then when any tweet is added by modi the this tweet notification will be sent to 100 users 
‚û§ For small scale applications if we  want to implement the event driven mechanism then we should go for observer design pattern.

üåü Benefits 
**************
‚û§ It describes the coupling between the objects and the observer 
‚û§ It provides the support for broadcast type communication 

üåü Usage 
**********
‚û§ When the change of a state in one object must be reflected in another object without keeping the objects tight coupled

Example: 
---------
package com.ashokit.desingpatterns.observerdesignpattern;

import java.util.ArrayList;
import java.util.List;

public class ObserverDesignPatternExample {

	public static void main(String[] args) {
		Follower karthik = new Follower("Kartik");
		Follower babu = new Follower("Babu");
		Follower suraj = new Follower("Suraj");
		Follower deepak = new Follower("Deepak");
		Follower viper = new Follower("Viper");
		Follower arnab = new Follower("Arnab");
		Follower rashid = new Follower("Rashid");
		
		InsuranceCompany LIC = new InsuranceCompany("LIC");
		InsuranceCompany TATA = new InsuranceCompany("TATA AIA");
		
		LIC.addSubscriber(karthik);
		LIC.addSubscriber(viper);
		LIC.addSubscriber(suraj);
		LIC.addSubscriber(deepak);
		LIC.addSubscriber(babu);
		
		TATA.addSubscriber(arnab);
		TATA.addSubscriber(rashid);
		
		LIC.broadcastMessage("Hi Everyone -> new policy called Jeevan anand is introduced");
		TATA.broadcastMessage("Hey tata website is not available from 12am to 1pm");
	}
}

interface FollowerNotification{
	void notification(String tweet);
}

class Follower implements FollowerNotification{
	String name;
	
	Follower(String name){
		this.name = name;
	}

	@Override
	public void notification(String tweet) {
		// TODO Auto-generated method stub
		System.out.println(name+" has notification received "+ tweet);
	}
	
}

interface ManageSubscriberAndNotify{
	
	public void addSubscriber(FollowerNotification r);
	public void removeSubscriber(FollowerNotification r);
	public void notifyAllSubscriber(String tweet);
}

class InsuranceCompany implements ManageSubscriberAndNotify{

	String name;
	InsuranceCompany(String name){
		this.name = name;
	}
	
	List<FollowerNotification> subscriberList = new ArrayList<>();
	
	@Override
	public void addSubscriber(FollowerNotification r) {
		// TODO Auto-generated method stub
		subscriberList.add(r);
	}

	@Override
	public void removeSubscriber(FollowerNotification r) {
		// TODO Auto-generated method stub
		subscriberList.remove(r);
	}

	@Override
	public void notifyAllSubscriber(String tweet) {
		// TODO Auto-generated method stub
		subscriberList.forEach(f -> f.notification(tweet));
	}
	
	public void broadcastMessage(String tweet) {
		notifyAllSubscriber(tweet);
	}
	
	
}

##############################
‚ùÑÔ∏è Strategy Desing Pattern 
###############################
‚û§ Strategy pattern (also known as the policy pattern) is behavioural software design pattern that enables selecting an algo at runtime. Instead of implementing a single algo directly code receives run time instructions as to which in a family of algo to use 
‚û§ The application can switch strategies at run time 
‚û§ Strategy enables the clients to choose the required algo without using a switch  statement or a series of if else statements 

üåü When to use startegy design pattern ?
===========================================
‚û§ Use the strategy pattern when you want to use different variants of an algo within an object and be able to switch from one algo to another during runtime. Use the startegy when you have a lot of similar classes that only differ in the way they execute some behaviour 

‚û§ Here some examples of startegy in core java libraries: 
üëâ java.util.Comparator#compare() called from Collections#sort() 
üëâ javax.servlet.http.HttpServlet:service() method, plus all of the doxxx() methods that accept HttpServletRequest and HttpServletResponse objects as arguments. 

Example: 
---------
package com.ashokit.desingpatterns.strategydesignpattern;

public class StrategyDesignPatternBankExample {

	public static void main(String[] args) {
		Customer c = new Customer(new PreferredCustomer());
		c.showInterest();
		
		Customer c1 = new Customer(new RegularCustomer());
		c1.showInterest();
	}
}

interface CustomerType{
	public void interestRate();
}

class PreferredCustomer implements CustomerType{

	@Override
	public void interestRate() {
		// TODO Auto-generated method stub
		System.out.println("Interest Rate is 9.7%");
	}
	
}

class RegularCustomer implements CustomerType{

	@Override
	public void interestRate() {
		// TODO Auto-generated method stub
		System.out.println("Interest Rate is 10%");
	}
	
}

class Customer {
	
	private CustomerType c;
	public Customer(CustomerType c) {
		
		this.c = c;
		
	}
	
	void showInterest() {
		c.interestRate();
	}
}

-> In the above example we are passing the object of the class based on which it is decided which class showInterest() method will be executed.

############################
‚ùÑÔ∏è Template Design Pattern 
############################
‚û§ The template method is a method in a superclass usually an abstract super class and defines the  skeleton of an operation in terms of a number of high level steps. These steps are themselves implemented by additional helper methods in the same class as the template method. 
‚û§ The intent of the tmeplate method is to define the overall structure of the operation while allowing subclasses to refine or redefine certain steps.
‚û§ Template method defines the steps to execute an algorithm and it can provide default implementation that might be common for all or some of the subclass.

‚û§ Let's understand this pattern with an example suppose we want to provide an algo to build a house . The steps need to be performed to build a house are building foundation, building pillars, building walls and windows. The important point is that we cant change the order of execution because we cant build windows before building the foundation . So in this case we can create a template method that will use different methods to build the house.

Example: 
--------
package com.ashokit.desingpatterns.templatedesignpattern;

public class TemplateDesignPatternExample {

	public static void main(String[] args) {
		Account a = new Account("Karthik", 1000);
		Transaction t = new DebitTransaction(a);
		t.templateMethod(2000);
		Transaction t1 = new CreditTransaction(a);
		t1.templateMethod(3000);
	}
	
}

//The template method should be final otherwise any of the class implementing the Transaction class will be able to override this 
//We don't want that we want that this order should be followed so we will make it final.

abstract class Transaction{
	
	public final void templateMethod(double amt) {
		if(authenticate() && validateInput() && updateLogsDB() && perfromTransaction(amt)) {  
			notifyUser();
		}
	}
	
	public abstract boolean authenticate();
	public abstract boolean validateInput();
	public boolean updateLogsDB() {
		System.out.println("DB updates/Log");
		return true;
	}
	public abstract boolean perfromTransaction(double amt);  
	public boolean notifyUser() {
		System.out.println("Successfull transaction");
		return true;
	}
	
}

class DebitTransaction extends Transaction {

	Account a;
	DebitTransaction(Account a){
		this.a = a;
	}
	@Override
	public boolean authenticate() {
		// TODO Auto-generated method stub
		System.out.println("Debit authenticate");
		return true;
	}

	@Override
	public boolean validateInput() {
		// TODO Auto-generated method stub
		System.out.println("Validated and amount is not negative");
		return true;
	}

	@Override
	public boolean perfromTransaction(double amt) {
		// TODO Auto-generated method stub
		a.debitTransaction(amt);
		return true;
	}
	
}

class CreditTransaction extends Transaction {

	Account a;
	CreditTransaction(Account a){
		this.a = a;
	}
	@Override
	public boolean authenticate() {
		// TODO Auto-generated method stub
		System.out.println("Debit authenticate");
		return true;
	}

	@Override
	public boolean validateInput() {
		// TODO Auto-generated method stub
		System.out.println("Validated and amount is not negative");
		return true;
	}

	@Override
	public boolean perfromTransaction(double amt) {
		// TODO Auto-generated method stub
		a.creditTransaction(amt);
		return true;
	}
	
}

class Account {
	String accountHolderName;
	double accountBalance;
	
	public Account(String name, double balance) {
		this.accountHolderName = name;
		this.accountBalance = balance;
	}
	
	public void debitTransaction(double amtToBeDebited) {
		accountBalance = accountBalance-amtToBeDebited;
	}
	
	public void creditTransaction(double amtToBeDebited) {
		accountBalance = accountBalance+amtToBeDebited;
	}
}

#############################
‚ùÑÔ∏è Prototype Design Pattern 
#############################
‚û§ Prototype design pattern is nothing but creating multiple objects using clone.
‚û§ Clonable interface is itself an example of prototype design pattern.

####################################
‚ùÑÔ∏è Abstract Factory Design Pattern 
####################################
‚û§ Providing one more abstract layer above the factory is called as abstract factory. 
üëâ Difference between abstract factory and factory 
=====================================================
‚û§ The main difference between the abstract factory and factory pattern is the level of abstraction they provide 
‚û§ In the e-commerce example code provided above the additional layer of abstraction is provided by the AbstractProductFactory interface and its concrete factory implementations ClothingFactory and ElectronicFactory 
‚û§ The ProductFactory interface in the code represents the factory pattern and is responsible for creating a single type of product

‚û§ The factory pattern provides an interface/abstract for creating objects of single type without specifying their concrete classes. The client code uses the factory interface to create objects and does not need to know the details of the object creation process.
‚û§ On the other hand the abstract factory pattern provides an interface for creating families of related objects without specifying their concrete classes. The client code uses the abstract factory interface to create objects but also needs to know which family of related objects it wants to create.

‚û§ The abstract factory pattern is best suited for scenarios where a system need to be independent of how its products are created composed and represented. It provides and interface for creating families of related products without specifying their concrete classes, which makes it easier to change the type of product families being used by the system . In summary the factory pattern is suitable when a system need to create obejcts of a single type while the abstract factory pattern is suitable when a system need to create families of related objects.

##########################
‚ùÑÔ∏è Facade Design Pattern 
##########################
‚û§ The facade pattern is appropriate when we have a complex system that we want to expose to clients in a simplified way. Its purpose is to hide internal complexity behind a single interface that appears simple from the outside 
‚û§ The interface JDBC can be called a facade because we as users or clients create connection using the java.sql.Connection interface the implementation of which we are not concerned about. The implementation is left to the vendor of driver.  
‚û§ We must have connected to database to fetch some data. We simply call the method dataSource.getConnection() to get the connection but internally a lot of things happen such as loading the driver creating connection from  pool update stats and then return the connection reference to caller method. It is another example of facade pattern in the programming world. 
‚û§ Developers often use the facade design pattern when a system is very complex or difficult to understand because the system has many interdependent classesor because its source code is unavailable . This pattern hides the complexities of the larger system and provides a simpler interface to the client

üåü Factory Pattern
*******************
‚û§ The factory completely abstracts the creation and initialization of the product from the client 
‚û§ This indirection enables the client to focus on its discrete role in the application without concerning itself with the details of how the product is created . Thus, as the product implementation changes over time the client remains unchanged 

CLIENT ---------> FACTORY ----------> PRODUCT 

üåü Facade Pattern 
*******************
‚û§ Encapsulate the subsytem using a high level interface/provides a simplified and uniform interface to a large subsystem of classes 
‚û§ The client communicates with the facade which has methods to interact with subsystems. The client very rarely accesses objects in the subsystems. 
‚û§ Subsystems objects usually retain no knowledge of the client.
‚û§ Subsystem objects do not normally maintain any refrence to facade 

CLIENT --------------> FACADE -----------------> SUBSYSTEMS.

##########################
‚ùÑÔ∏è Proxy Design Pattern 
##########################
‚û§ A Proxy object hides the original object and control access to it . We can use proxy when we may want to use a class that can perform as an interface to something else.
‚û§ Proxy is heavily used to implement lazy loading related usecases where we do not want to create full object until it is actually needed.
‚û§ A proxy can be used to add an addtional security layer around the original object as well.

‚û§ Intrinsic and extrinsic are two terms used in the context of the Proxy design pattern 
‚û§ Intrinsic means that the behaviour is part of the object itself In the context of the proxy pattern intrinsic behaviour refers to the behaviour that is implemented by the proxy itself. 
‚û§ Extrinsic means that the behaviour is not part of the object iteself but is instead provided by an external entity . In the context of the proxy pattern extrinsic behaviour refers to the behaviour that is provided by the real subject.

#############################
‚ùÑÔ∏è Momento Design Pattern 
#############################
‚û§ The momento pattern could be suitable for a feedback application. For example you could use the momento pattern to save the stateof the feedback form before and after the user submits the feedback. This would allow the user to review and edit their feedback before submitting it and also provide an undo option in case they change their mind.
‚û§ It is a behavioural design pattern that lets you save and restore the previous state of an object without revealing the details of its implementation 
‚û§ There are three important classes(Orignator, Memento and Caretaker) involved in the momento design pattern 
‚û§ The originator class has two methods. One is CreateMemento and the other one is setMemento. The setMemento method accepts the memento object. So what this originator class will do is , it will instantiate the memento object and set the internal state of the originator to memento state. So, basically what the originator will do is it will take a snapshot of the originator and put it on the memento object. And that memento object will save into the Caretaker for later use. 
‚û§ Later use means, suppose at a later point of time originator wants to restore its state then at that time it will take the old state from the caretaker and set it in the originator state so that the originator can restore its old state.

‚û§ This can be used in any feedback form

Example: 
---------
package com.ashokit.desingpatterns.mementodesignpattern;

public class MementoDesignPatternExample {

	public static void main(String[] args) {
		FeedbackForm form = new FeedbackForm("Kartik","karthik.abc@gmail.com","Food is good");
		FeedbackCaretaker careTaker = new FeedbackCaretaker();
		careTaker.saveState(form);
		
		form.setName("ABC");
		form.setEmail("abc@gmail.com");
		form.setComment("Form is filled");
		
		careTaker.restoreState(form);
	}
}

class FeedbackForm{ //originator 
	private String name;
	private String email;
	private String comment;
	public FeedbackForm(String name, String email, String comment) {
		this.name = name;
		this.email = email;
		this.comment = comment;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getComment() {
		return comment;
	}
	public void setComment(String comment) {
		this.comment = comment;
	}
	 
	FeedbackMemento save(FeedbackForm form){
		FeedbackMemento memento = new FeedbackMemento(form.getName(), form.getEmail(), form.getComment());
		return memento;
	}
	
	void restore(FeedbackMemento form) {
		this.name = form.getName();
		this.email = form.getEmail();
		this.comment = form.getComment();
		System.out.println("Name is "+name+" email id is "+email+" comment is "+comment);
	}
}

class FeedbackMemento{ //Memento 
	private String name;
	private String email;
	private String comment;
	public FeedbackMemento(String name, String email, String comment) {
		this.name = name;
		this.email = email;
		this.comment = comment;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getComment() {
		return comment;
	}
	public void setComment(String comment) {
		this.comment = comment;
	}
}

class FeedbackCaretaker{
	FeedbackMemento memento; 
	
	public void saveState(FeedbackForm form) {
		 memento = form.save(form);
	}
	
	public void restoreState(FeedbackForm form) {
		form.restore(memento);
	}
}

###########################
‚ùÑÔ∏è Bridge Design Pattern 
###########################
‚û§ The bridge design pattern is a structural design pattern that decouples an abstraction from its implementation so that both can vary independently . In other words it separates the interface from its implementation so that they can be modified without affecting each other.
‚û§ How is it different from adapter ? 
=> Adapter  make two interfaces compatible to work and it can be used for the existing projects where as bridge should be used for the new projects.

#########################
‚ùÑÔ∏è State Design Pattern 
#########################
‚û§ The state design pattern is a behavioural pattern that allows an object to change its behaviour when its internal state changes . The pattern allows an object to change its behaviour by delegating to an object representing the current state. The state object is responsible for changing the behaviour of the original object, based on its current state.
‚û§ Means whenever you are changing the internal behaviour then objects state will be changed.

###########################
‚ùÑÔ∏è Command Design Pattern 
###########################
‚û§ The command pattern is a behavioural design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time . The information includes the method name the object that owns the method and values for the method parameters. 
‚û§ Four terms always associated with the command pattern are command ,receiver, inovker and client 
‚û§ In the command design pattern there's a command object that sits between the sender and the receiver objects 
‚û§ The sender object can create a command object. The command object then calls the exposed method in the receiver. And so the sender object doesn't need to know about the receiver and its exposed methods.
‚û§ We also have another object known as invoker . An invoker is an object responsible for invoking the appropriate command objects to complete a task. 

‚û§ It is a behavioral pattern in software engineering that encapsulates a request or command as an object, allowing it to be parameterized with different requests, queued, logged or even undone. This pattern allows for the separation of concerns between the client that sends the request and the receiver that executes it.It also supports the addition of new commands without changing the client code or the receiver code. 
The command pattern involves the following components: 
‚û§ Command: This is an interface or abstract class that defines the common methods that all concrete commands must implement. 
‚û§ Concrete command: These are concrete classes that implement the command interface and provide an implementation for the execute method. Each concrete command encapsulates a specific action that the receiver can perform 
‚û§ Receiver: This is the object that performs the actual action when a command is executed. It  defines the operations that can be performed and is responsible for implementing the methods called by the concrete commands 
‚û§ Invoker: This is the object that is responsible for initiating a request or command. It holds a reference to the command object and invokes its execute method when the request needs to be processed. 
‚û§ Client: This is the object that creates the command objects and sets their receiver, if necessary. It is also responsible for creating and managing the invoker object 

‚û§ The command pattern provides a way to decouple the sender of a request from the object that performs the action. This makes it easier to add new commands or modify the behaviour of existing ones without affecting other parts of the system . It also provides a way to implement undo or redo functionality, as well as support for logging or queuing requests.

#############################
‚ùÑÔ∏è Composite Design Pattern 
#############################
‚û§ The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to compare objects into tree structures to represent part whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly 
‚û§ The composite design pattern allows us to arrange objects into tree structure to represent part whole hierarchies. It allows client to treat individual objects as well as collection of objects in similar manner. For client the interface to interact with individual objects and composites remains the same client doesnt require differnet code for handling individual or collection of objects. 
‚û§ Composite pattern comes under structural design pattern as it provide one of the best ways to arrange similar objects in hierarichal order. A composite object may contains a collection object where each object itself can be composite 

üåü Advantages of Composite Pattern 
************************************
‚û§ It provides a hierarichal tree structure to represent composite and individual objects 
‚û§ It allows clients treat individual objects and compositions of objects uniformly 
‚û§ We can change the structure of tree any time by calling methods of composite objects like addNode , removeNodes etc. 

##############################
‚ùÑÔ∏è Fly weight Design Pattern 
##############################
‚û§ The main intent of flyweight design pattern is "Facilitates the reuse of many fine grained objects and makes the use of large number of objects more efficient". In other words the flyweight pattern explains how objects can be distributed so that they can be used without restrictive costs in fine granules. In software development each "Flyweight" object is categorized into two parts: the extrinsic state - dependent part and the intrinsic state - independent part . So the intrinsic state of the flyweight object is shared whereas extrinsic state is stored or computed by user objects and invoked to the flyweight object. 

‚û§ The flyweight object essentially has two different kind of attributes: 
=> Intrinsic: An intrinsic(invariant) state attribute is stored and shared in the flyweight object. It is independent of flyweight's context. So as the best practice we should make intrinsic states immutable. 
=> Extrinsic: An extrinsic(variant) state attribute does not store and share in the flyweight object because it depends on flyweight's context and varies as the context change. Generally we store and maintain the extrinsic state in the client objects. We need to pass the extrinsic state to the flyweight object for object creation and processing.

üëâ Why do we care for number of objects in our program? 
‚û§ Less number of objects reduces the memory usage, and it manages to keep us away from errors related to memory like java.lang.OutOfMemoryError. 
‚û§ Although creating an object in java is really fast ,we can still reduce the execution time of our program by sharing objects 

üåü Differnce between singleton and flyweight pattern 
******************************************************
‚û§ The singleton pattern helps us maintain only one object in the system. In other words once the requried object is created we cant create more. We need to reuse the existing object in all parts of the application. 
‚û§ The flyweight pattern is used when we have to create large number of similar objects which are different based on client provided extrinsic attribute. 

############################
‚ùÑÔ∏è Mediator Design Pattern 
############################
‚û§ The intent of the mediator pattern is to reduce the complexity and dependencies between tightly coupled objects communicating directly with one another. 
Allows loose coupling by encapsulating the way disparate sets of objects interact and communicate with each other. Allows for the actions of each object set to vary independently of one another.
‚û§ This promotes loose coupling as a set of components working together no longer have to interact directly . Instead they only refer to the single mediator object . This way its is also easier to reuse these objects in other parts of the system. 
‚û§ In OOPs programs often consist of many classes. Business logic and computation are distributed among these classes. However as more classes are added to a program especially during maintenance and/or refactoring the problem of communicationi between these classes may become more complex. This makes the program harder to read and maintain. Furthermore it can become difficult to change the program since any change may affect code in several other classes. 
‚û§ With the mediator pattern communication between objects in encapsulated within a mediator object. Objects no longer communicate directly with each other, but instead communicate through the mediator. This reduces the dependencies between communicating objects thereby reducing coupling.
‚û§ Example : Chat application in this we have several participants . It's not a good idea to connect each participant to all the others because the number of connection would be really high . The best solution is to have a hub where all participants will connect this hub is just the mediator class.

üëâ Mediator commonly consists of these four components: 
‚û§ Mediator: Defines communication between collegues 
‚û§ Mediator is typically and abstract based class or interface 

‚û§ Concrete mediator: Implements communication between collegues.
‚û§ Collegue : Communicates only with one mediator
‚û§ Concrete collegue : Receive messages from the mediator. 

###############################
‚ùÑÔ∏è Interpreter Design Pattern 
###############################
‚û§ The interpreter design pattern is a behavioural pattern that defines a way to evaluate and interpret sentences or expressions in a language. It invloves defining a grammer or language syntax and then implementing a parser that can parse and interpret expressions written in that language 
Example: 
expression::= gender | age | policyType 
gender::= "male" | "female"
age::= "age" comp number 
comp::= "<" | ">" | "=" 
number::= digit{digit}
digit::= "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"
policyType::="basic"|"premium"

##########
‚ùÑÔ∏è SOLID 
##########
S : Single Responsibility 
‚û§ Every class you will be writing should have a single responsibility.

O : Open Closed Principle 
‚û§ It means open for extension and closed for modification.

L : Liskov Substitution Principle 

I : Interface Seggregation Principle 

D : Dependency Inversion Principle 

###############################
‚ùÑÔ∏è Service Discovery Pattern 
##############################
‚û§ It is a pattern used in microservices architecture to locate and discover other microservices in a distributed system. The main idea behind this pattern is that microservices can register themselves with a service registry or discovery service, and other microservices can look up and discover the registered services using the registry 
‚û§ The service discovery pattern involves two main components a service registry and a client side service discovery mechanism. The service registry is responsible for maintaining a list of available services and their network locations. The client side discovery mechanism is responsible for querying the registry to discover available services 
‚û§ Eureka server is an example of a service registry that can be used to implement the service discovery pattern . Eureka server is a self contained service that can be used to register and discover services in a microservices architecture.

üåü The need for service discovery 
************************************
‚û§ A microservice needs to know the location (IP address and port) every service it communicates with.

#########################
‚ùÑÔ∏è Database per service
#########################

################
‚ùÑÔ∏è API gateway 
################

#########################
‚ùÑÔ∏è Distributed Tracing 
#########################
‚û§ Spring cloud sieuth adds some additional properties to the logs that are related to distributed tracing. Some of the key properties of sieuth logs are: 
1. Trace ID: Trace ID is a unique identifier that is assigned to a request when it enters the system . It is used to identify the entire trace across multiple services.
2. Span ID: Span ID is a unique identifier that is assigned to a specific operation within a trace . Each operation in the trace is assigned a new span ID. 
3. Parent Span ID: Parent Span ID is used to identify the parent operation within a current operation.
4. Exportable: This property is used to indicate whether the current span should be exported to the tracing system. If this property is set to false, the span will not be sent to the tracing system.
5. Baggage: It is a collection of key value pairs that can be attached to a span . It can be used to propagate information across multiple services. 
These properties are added to the logs to enable distributed tracing across multiple services. They can be used to correlate logs across services and identify performance issues and errors in the distributed system.

üëâ The best distributed tracing techniques that can be used in real time production grade applications for java are: 
‚û§ Spring cloud Sleuth with Zipkin: Spring cloud sleuth is a framework that provides distributed tracing capabilities for spring boot applications. It integrates seamlessly with zipkin an open source distributed tracing system . Spring cloud sleuth adds trace and span id to the logs and zipkin provides a user interface for visualising the trace data. 
‚û§ Jaeger: It is an open source end to end distributed tracing tool that supports multiple languages and frameworks including java . Jaeger provides a user interface for visualising the trace data and can be integrated with various logging and monitoring systems. 
‚û§ AWS X-ray: It is distributed tracing tool provided by amazon web services. It can be used to trace requests across multiple services running on aws and provides a visualisation of the request flow . AWS X-ray supports java and other popular languages and frameworks 
‚û§ Datadog: It is a cloud monitoring platform that provides distributed tracing, logging and metrics monitoring . It supports several languages and frameworks, including java and provides a user interface for visualizing the trace data.

####################
‚ùÑÔ∏è Circuit Breaker 
####################
‚û§ It provides a fallback mechanism.
üëâ There are several ways to implement the circuit breaker pattern in java based microservices. Here are some of the most common approaches: 
‚û§ Hystrix: It is a popular java library developed by netflix that provides circuit breaker functionality . It integrates with popular java based microservices frameworks like spring cloud and provides several features such as request caching ,fallbacks ,and bulkheads.
‚û§ Ressilience4j: It is another java library that provides circuit breaker functionality .It offers a similar set of feautres to hystrix but with a more modular design that allows you to mix and match different resilience pattern.
‚û§ Sentinel: It is a lightweight java library developed by alibaba that provides several resilience patterns, including circuit breaking .It offers features like real time monitoring rule based throttling, and advanced dashboarding. 
‚û§ Spring cloud circuit breaker: It is a module of the spring cloud framework that provides an abstraction layer for circuit breaker functionality. It allows you to switch between different circuit breaker implementations without changing your code.
‚û§ Akka : It is a java based toolkit and runtime for building highly concurrent , distributed and fault tolerant systems .It provides a circuit breaker implementation that integrates well with akka based microservices.