###############################
ðŸ§© CREATIONAL DESIGN PATTERNS
###############################
ðŸ§© Singleton Pattern
**********************
âž¤ Ensures only one instance of a class exists
âž¤ Provides global access point
âž¤ Used for shared resources (Logger, DB connection, Config)

âž¤ Common implementations:
âž¤ Eager
âž¤ Lazy
âž¤ Double-Checked Locking (volatile)
âž¤ Bill Pugh (Best)
âž¤ Enum Singleton (Most secure)

âž¤ Problems handled:
âž¤ Thread safety
âž¤ Serialization
âž¤ Reflection
âž¤ Cloning

âž¤ Real examples:
âž¤ Runtime.getRuntime()
âž¤ Spring Beans (default scope)

ðŸ§© Factory Pattern
********************
âž¤ Creates objects without exposing creation logic
âž¤ Returns objects based on input
âž¤ Client depends on interface, not concrete class

âž¤ Benefits:
âž¤ Loose coupling
âž¤ Centralized object creation
âž¤ Follows OCP

âž¤ Real examples:
âž¤ DriverManager.getConnection()
âž¤ Calendar.getInstance()

ðŸ§© Abstract Factory Pattern
******************************
âž¤ Factory of factories
âž¤ Creates families of related objects
âž¤ Ensures product consistency

âž¤ Difference from Factory:
âž¤ Factory â†’ one product
âž¤ Abstract Factory â†’ multiple related products

âž¤ Used in:
âž¤ UI themes
âž¤ Spring framework

ðŸ§© Builder Pattern
*********************
âž¤ Builds complex objects step-by-step
âž¤ Avoids telescoping constructors
âž¤ Ideal for optional parameters
âž¤ Helps create immutable objects

âž¤ Key feature:
âž¤ Fluent API (.setX().setY().build())

âž¤ Used in:
âž¤ StringBuilder
âž¤ ProcessBuilder
âž¤ Lombok @Builder

ðŸ§© Prototype Pattern
**********************
âž¤ Creates objects by cloning existing objects
âž¤ Avoids costly object creation
âž¤ Uses clone() method

âž¤ Types:
âž¤ Shallow Copy
âž¤ Deep Copy

âž¤ Use case:
âž¤ When object creation is expensive

###############################
ðŸ§© STRUCTURAL DESIGN PATTERNS
###############################
ðŸ§© Adapter Pattern
*********************
âž¤ Converts one interface into another
âž¤ Allows incompatible classes to work together
âž¤ Uses composition (Object Adapter)

âž¤ Real examples:
âž¤ Arrays.asList()
âž¤ Spring HandlerAdapter

âž¤ Adapter â‰  Decorator
âž¤ Adapter â†’ interface conversion
âž¤ Decorator â†’ behavior addition

ðŸ§© Decorator Pattern
**********************
âž¤ Adds new behavior dynamically at runtime
âž¤ Uses wrapping instead of inheritance
âž¤ Avoids subclass explosion

âž¤ All decorators implement same interface
âž¤ Multiple decorators can be stacked

âž¤ Real examples:
âž¤ Java I/O Streams
âž¤ Logging, Caching

ðŸ§© Facade Pattern
*******************
âž¤ Provides simplified interface to complex subsystem
âž¤ Hides internal complexity
âž¤ Improves usability and readability

âž¤ Used in:
âž¤ Spring
âž¤ Logging frameworks

âž¤ Facade â‰  Adapter
âž¤ Facade simplifies
âž¤ Adapter converts interface

ðŸ§© Proxy Pattern
*******************
âž¤ Controls access to an object
âž¤ Adds extra behavior like security, caching, lazy loading

âž¤ Types:
âž¤ Virtual Proxy
âž¤ Protection Proxy
âž¤ Remote Proxy

âž¤ Used in:
âž¤ Spring AOP
âž¤ Hibernate lazy loading

ðŸ§© Bridge Pattern
*******************
âž¤ Separates abstraction from implementation
âž¤ Avoids class explosion
âž¤ Uses composition

âž¤ Example:
âž¤ Shape + Color
âž¤ JDBC Driver

âž¤ Bridge â‰  Adapter
âž¤ Bridge designed upfront
âž¤ Adapter used later

ðŸ§© Composite Pattern
************************
âž¤ Treats individual objects and groups uniformly
âž¤ Tree-like structure
âž¤ Client doesnâ€™t differentiate leaf & composite

âž¤ Used in:
âž¤ File systems
âž¤ UI components

ðŸ§© Flyweight Pattern
***********************
âž¤ Reduces memory usage
âž¤ Shares common objects
âž¤ Separates intrinsic & extrinsic state

âž¤ Used when:
âž¤ Large number of similar objects

âž¤ Example:
âž¤ Text editors
âž¤ Game characters

###############################
ðŸ§© BEHAVIORAL DESIGN PATTERNS
###############################
ðŸ§© Chain of Responsibility
****************************
âž¤ Passes request along a chain of handlers
âž¤ Each handler decides to process or forward
âž¤ Removes large if-else blocks

âž¤ Used in:
âž¤ Filters
âž¤ Logging
âž¤ Authentication

ðŸ§© Observer Pattern
**********************
âž¤ One-to-many dependency
âž¤ Observers get notified on state change
âž¤ Loose coupling

âž¤ Used in:
âž¤ Event listeners
âž¤ Kafka consumers
âž¤ UI frameworks

âž¤ Types:
âž¤ Push model
âž¤ Pull model

ðŸ§© Template Method Pattern
****************************
âž¤ Defines algorithm skeleton
âž¤ Subclasses override specific steps
âž¤ Code reuse

âž¤ Uses:
âž¤ Abstract class
âž¤ Hook methods

âž¤ Used in:
âž¤ JDBC
âž¤ Spring

ðŸ§© State Pattern
******************
âž¤ Object behavior changes based on internal state
âž¤ Eliminates state-based conditionals
âž¤ Each state is a separate class

âž¤ State â‰  Strategy
âž¤ State â†’ behavior depends on state
âž¤ Strategy â†’ interchangeable algorithms

ðŸ§© Command Pattern
*********************
âž¤ Encapsulates request as an object
âž¤ Supports undo/redo
âž¤ Decouples sender & receiver

âž¤ Used in:
âž¤ UI buttons
âž¤ Task queues

ðŸ§© Iterator Pattern
*********************
âž¤ Provides sequential access to collection
âž¤ Hides internal structure
âž¤ Standard traversal mechanism

âž¤ Used in:
âž¤ Java Collections (Iterator)

ðŸ§© Memento Pattern
********************
âž¤ Captures object state without exposing internals
âž¤ Supports undo/rollback
âž¤ Components:
âž¤ Originator
âž¤ Memento
âž¤ Caretaker

âž¤ Used in:
âž¤ Editors
âž¤ Transactions

ðŸ§© Mediator Pattern
*********************
âž¤ Centralizes communication between objects
âž¤ Reduces object-to-object dependencies
âž¤ Promotes loose coupling

âž¤ Used in:
âž¤ Chat applications
âž¤ UI dialogs

ðŸ§© Interpreter Pattern
************************
âž¤ Defines grammar & interprets expressions
âž¤ Used for simple language parsing
âž¤ Not suitable for complex grammars

âž¤ Used in:
âž¤ Expression evaluators
âž¤ Rule engines