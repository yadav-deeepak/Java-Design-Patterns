#############################
üß© Singleton Design Pattern 
#############################
‚û§ Definition
***************
The Singleton Pattern ensures that only one object of a class is created during the entire application lifecycle and provides a global point of access to that object.

üß© Why do we need Singleton?
******************************
‚û§ To control access to shared resources such as:
‚û§ Logging
‚û§ Database connection
‚û§ Caches
‚û§ Configuration settings
‚û§ Thread pools

üß© Key Characteristics (Must-Know for Interviews)
***************************************************
‚û§ Only one instance exists.
‚û§ Lazy or Eager creation depending on design.
‚û§ Global access point (getInstance() method).
‚û§ Must be thread-safe in multi-threaded applications.
‚û§ Must prevent cloning, reflection, and serialization from breaking the Singleton property (important interview point).

üß© Types of Singleton Implementations
***************************************
1) Eager Initialization (Simple & Thread-Safe)
===============================================
‚û§ Instance created at class loading time.

public class Singleton {
    private static final Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}

‚û§ Pros: Simple, thread-safe
‚û§ Cons: Instance created even if unused (memory waste)

2) Lazy Initialization (Not Thread-Safe)
===========================================
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

‚û§ Pros: Instance created only when needed
‚û§ Cons: Not thread-safe ‚Üí multiple threads may create multiple instances

3) Thread-Safe Singleton (Synchronized Method)
==============================================
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}

‚û§ Pros: Thread-safe
‚û§ Cons: Slow due to synchronization on every call

4) Double-Checked Locking (Best Performance)
==============================================
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

‚û§ Pros: Fast + thread-safe
‚û§ Cons: Slightly complex
‚û§ volatile is required to prevent instruction reordering

5) Bill Pugh (Static Inner Class) ‚Äì The Best Recommended Approach
==================================================================
public class Singleton {
    private Singleton() {}
    private static class Helper {
        private static final Singleton instance = new Singleton();
    }
    public static Singleton getInstance() {
        return Helper.instance;
    }
}

‚û§ Pros:
‚û§ Lazy-loaded
‚û§ Thread-safe
‚û§ No synchronization overhead
‚û§ Cons: None ‚Äî widely accepted as best practice

6) Enum Singleton (Most Robust)
=================================
public enum Singleton {
    INSTANCE;
}

‚û§ Pros:
‚û§ Prevents serialization issues
‚û§ Prevents reflection attacks
‚û§ Cons:
‚û§ Cannot be lazily loaded
‚û§ Less flexible (cannot extend another class)

üß© How Singleton Protects Against Attacks
*******************************************
‚û§ Reflection attack
‚û§ Private constructor may still be accessed
‚û§ Fix ‚Üí throw exception inside constructor

‚û§ Serialization attack
‚û§ Fix ‚Üí implement readResolve()

‚û§ Cloning attack
‚û§ Fix ‚Üí override clone to throw exception

üß© Real-World Examples
************************
‚û§ Database connection manager (JDBC)
‚û§ Spring beans (by default Singleton scope)
‚û§ Logger frameworks (Log4j, SLF4J)
‚û§ Runtime class in Java (Runtime.getRuntime() is a singleton)

üß© Advantages
****************
‚û§ Controlled access to a single shared resource
‚û§ Saves memory ‚Äî only one instance
‚û§ Avoids inconsistent state
‚û§ Useful for centralized configurations

üß© Disadvantages
*******************
‚û§ Hard to unit test (global state)
‚û§ Can become a God Object
‚û§ Can cause hidden dependencies
‚û§ Encourages tight coupling

üß© Frequently Asked Interview Questions
*****************************************
‚û§ What is a Singleton pattern?
‚û§ Why are Singletons used?
‚û§ Difference between lazy and eager initialization?
‚û§ How do you make a Singleton thread-safe?
‚û§ Why use volatile in double-checked locking?
‚û§ How does Singleton break with serialization/cloning/reflection?
‚û§ Why is Enum Singleton preferred?

############################
üß© Factory Design Pattern
############################
üß© Definition
***************
‚û§ The Factory Pattern (also called Factory Method Pattern) is a Creational Design Pattern that provides a way to create objects without exposing the object creation logic to the client.
‚û§ Instead of calling the constructor directly, the client uses a factory method to create objects.

üß© Intent (Why Factory Method?)
*********************************
‚û§ To define an interface for creating objects but let subclasses decide which class to instantiate.
‚û§ Helps in creating objects when the exact type is determined at runtime.
‚û§ Provides loose coupling by eliminating direct dependency on concrete classes.

üß© Key Characteristics (Must-Know for Interviews)
***************************************************
‚û§ Client uses factory instead of new.
‚û§ Reduces tight coupling between object creation and usage.
‚û§ Helps follow SOLID principles (especially OCP & SRP).
‚û§ Object type is selected based on input/logic.
‚û§ Easy to add new product types without modifying existing code.

üß© When to Use Factory Pattern?
*********************************
‚û§ When you don‚Äôt know the exact object to create until runtime
‚û§ When a class wants its subclasses to specify the objects it creates
‚û§ When object creation logic is complex
‚û§ When you want to centralize object creation
‚û§ When you want to reduce dependency on concrete classes

üß© Real-World Examples
**************************
‚û§ Java Calendar.getInstance()
‚û§ JDBC DriverManager.getConnection()
‚û§ Spring Bean Factory / ApplicationContext
‚û§ NumberFormat.getInstance()
‚û§ Log4j LogManager

üß© Simple Example ‚Äî Without Factory (Problem)
================================================
Car car = new Swift();  // tightly coupled to Swift class

‚û§ Problem: If you want Baleno or Fortuner ‚Üí modify code everywhere.

üß© Using Factory Pattern (Solution)
======================================
Step 1: Create Product Interface
---------------------------------
public interface Car {
    void drive();
}

Step 2: Create Concrete Products
-----------------------------------
public class Swift implements Car {
    public void drive() { System.out.println("Swift driving..."); }
}

public class Baleno implements Car {
    public void drive() { System.out.println("Baleno driving..."); }
}

Step 3: Create Factory Class
-------------------------------
public class CarFactory {

    public static Car getCar(String type) {
        if (type.equalsIgnoreCase("swift")) {
            return new Swift();
        } else if (type.equalsIgnoreCase("baleno")) {
            return new Baleno();
        }
        return null;
    }
}

Step 4: Client Code
--------------------
Car car = CarFactory.getCar("baleno");
car.drive();

‚û§ Client does not know how objects are created ‚Üí loose coupling achieved.

üß© Factory Pattern UML Structure
**********************************
‚û§ Creator (Factory Class)
‚û§ Contains Factory Method (getObject())

‚û§ Product Interface (Common Parent)
‚û§ Car

‚û§ Concrete Products
‚û§ Swift
‚û§ Baleno

‚û§ Client
‚û§ Calls the factory

üß© Advantages
****************
‚û§ Less coupling between client and objects
‚û§ Centralized object creation
‚û§ Code becomes more maintainable
‚û§ Follows Open/Closed Principle
‚û§ Helpful when object creation is complex

üß© Disadvantages
********************
‚û§ More classes (Factory + Product classes)
‚û§ Sometimes adds unnecessary abstraction
‚û§ Switch/if-else can grow if many products are added
‚û§ (But can be fixed using more advanced patterns like Abstract Factory or Factory Method Pattern with inheritance)

üß© Variations of Factory Pattern
***********************************
1) Simple Factory (Not part of GoF, but commonly used)
=========================================================
‚û§ A single factory class with logic to create objects ‚Üí the one we wrote above.

2) Factory Method Pattern (GoF)
================================
‚û§ Lets subclasses decide which class to instantiate
‚û§ Uses inheritance

3) Abstract Factory Pattern
==============================
‚û§ Creates families of related objects
‚û§ Example: UI themes (DarkThemeButton, DarkThemeCheckbox)

üß© Interview Questions (Very Common)
***************************************
‚û§ What is the Factory Method Pattern?
‚û§ How is it different from Abstract Factory?
‚û§ Why not use constructors directly?
‚û§ What problem does Factory solve?
‚û§ Where is Factory used in Java?
‚û§ How does Factory support OCP?
‚û§ Can Factory return different objects based on configuration? (Yes)

############################################
üß© Chain of Responsibility Design Pattern 
############################################
üß© Definition
****************
‚û§ The Chain of Responsibility (CoR) is a Behavioral Design Pattern that allows you to pass a request along a chain of handlers, where each handler decides:
‚û§ whether to process the request, OR
‚û§ pass it to the next handler in the chain.

‚û§ This pattern decouples the sender and receiver and avoids if-else/switch ladders.

üß© Intent (Why Chain of Responsibility?)
******************************************
‚û§ To avoid tightly coupling request sender and receiver.
‚û§ To allow multiple objects a chance to process a request.
‚û§ To build flexible and dynamic chains of handlers.
‚û§ To replace long if-else conditions with clean handler objects.

üß© Real-World Examples
************************
‚û§ Customer support escalation
‚û§ Level 1 ‚Üí Level 2 ‚Üí Level 3
‚û§ ATM withdrawal handler
‚û§ Authentication filters in web security
‚û§ Logging frameworks (INFO ‚Üí DEBUG ‚Üí ERROR)
‚û§ Servlet filters in Java EE
‚û§ Spring Boot Handler Interceptors / Filter Chains
‚û§ Exception handling chain

üß© When to Use CoR Pattern?
******************************
‚û§ When multiple handlers can process a request.
‚û§ When you want to remove large conditional blocks.
‚û§ When handlers should be dynamically arranged.
‚û§ When requests need to be processed or forwarded without knowledge of the receiving handler.

üß© Key Characteristics (Must Know for Interviews)
****************************************************
‚û§ Each handler has a reference to the next handler.
‚û§ Request moves step-by-step through the chain.
‚û§ Handler can:
‚û§ Handle the request
‚û§ OR pass it along
‚û§ OR do both
‚û§ Follows Open/Closed Principle ‚Üí new handlers can be added easily.
‚û§ Decouples sender from receiver.

üß© Structure (UML Essentials)
********************************
‚û§ Handler (abstract class / interface)
‚û§ Defines method to handle request
‚û§ Has reference to next handler

‚û§ Concrete Handlers
‚û§ Implement the actual logic
‚û§ Decide to handle or forward

‚û§ Client
‚û§ Creates and links handlers
‚û§ Sends request to the first handler

üß© Java Example ‚Äî Support Ticket Chain
****************************************
1) Handler Interface
---------------------
public abstract class SupportHandler {
    protected SupportHandler next;

    public void setNextHandler(SupportHandler next) {
        this.next = next;
    }
    public abstract void handleRequest(String issueLevel);
}

2) Concrete Handlers
-----------------------
public class Level1Support extends SupportHandler {
    @Override
    public void handleRequest(String issueLevel) {
        if (issueLevel.equals("LOW")) {
            System.out.println("Level 1 handled the issue");
        } else if (next != null) {
            next.handleRequest(issueLevel);
        }
    }
}

public class Level2Support extends SupportHandler {
    @Override
    public void handleRequest(String issueLevel) {
        if (issueLevel.equals("MEDIUM")) {
            System.out.println("Level 2 handled the issue");
        } else if (next != null) {
            next.handleRequest(issueLevel);
        }
    }
}

public class Level3Support extends SupportHandler {
    @Override
    public void handleRequest(String issueLevel) {
        if (issueLevel.equals("HIGH")) {
            System.out.println("Level 3 handled the issue");
        } else {
            System.out.println("Issue cannot be handled!");
        }
    }
}

3) Client Code
---------------
public class Client {
    public static void main(String[] args) {
        SupportHandler l1 = new Level1Support();
        SupportHandler l2 = new Level2Support();
        SupportHandler l3 = new Level3Support();

        l1.setNextHandler(l2);
        l2.setNextHandler(l3);

        l1.handleRequest("MEDIUM");
    }
}

üß© Output
===========
Level 2 handled the issue

üß© Advantages
***************
‚û§ Eliminates long if-else chains
‚û§ Easy to add new handlers
‚û§ Loose coupling between sender and receiver
‚û§ Follows SRP (each handler has its own logic)
‚û§ Flexible ‚Äî order of handlers can be changed at runtime

üß© Disadvantages
******************
‚û§ Request may go unhandled if chain ends
‚û§ Debugging can be difficult due to indirect flow
‚û§ Performance overhead if chain is long
‚û§ Needs careful ordering of handlers

üß© Common Interview Questions
*******************************
‚û§ What is Chain of Responsibility?
‚û§ How does it reduce coupling?
‚û§ Difference between CoR and Decorator?
‚û§ Can handler both process and forward the request?
‚û§ Real-world examples of CoR?
‚û§ How is it implemented in frameworks like Spring/Servlets?
‚û§ What happens if no handler processes the request?

üß© Difference: Chain of Responsibility vs. Decorator
*******************************************************
‚û§ CoR passes request along a chain ‚Üí only one may handle.
‚û§ Decorator adds additional behavior ‚Üí all decorators execute.

############################
üß© Builder Design Pattern 
############################
üß© Definition
****************
‚û§ The Builder Pattern is a Creational Design Pattern used to construct complex objects step-by-step.
‚û§ Instead of using a large constructor with many parameters, Builder provides a flexible, readable, and controlled way to create objects.

üß© Intent (Why Builder Pattern?)
**********************************
‚û§ To avoid telescoping constructors (constructors with too many parameters).
‚û§ To create objects with optional or mandatory fields clearly.
‚û§ To construct complex objects step-by-step.
‚û§ To build immutable objects safely.

üß© Where Builder is Used in Real Life?
****************************************
‚û§ Creating objects with multiple attributes
‚û§ Building immutable classes (e.g., in Lombok @Builder)
‚û§ Creating HTTP requests (OKHttp, Retrofit)
‚û§ JDBC PreparedStatement building
‚û§ Spring MockMvcBuilders
‚û§ StringBuilder in Java uses a similar but not exact pattern

üß© Problem Without Builder (Telescoping Constructor)
*****************************************************
public class User {
    public User(String name, String email, int age, String address, String phone) {
        // too many params ‚Üí confusing
    }
}

‚û§ Hard to read
‚û§ Hard to maintain
‚û§ Error-prone

üß© Solution: Builder Pattern
********************************
üß± Step-by-Step Object Construction
=====================================
‚û§ Builder allows you to set only the fields you need.
‚û§ Gives chained methods (fluent API).
‚û§ Final object is built using .build().

üß© Complete Java Example
-------------------------
1Ô∏è‚É£ Class to Build
public class User {
    private String name;
    private String email;
    private int age;
    private String address;

    private User(UserBuilder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
        this.address = builder.address;
    }

    public static class UserBuilder {
        private String name;
        private String email;
        private int age;
        private String address;

        public UserBuilder setName(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder setEmail(String email) {
            this.email = email;
            return this;
        }

        public UserBuilder setAge(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder setAddress(String address) {
            this.address = address;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}

2Ô∏è‚É£ Client Code
User user = new User.UserBuilder()
                .setName("Deepak")
                .setEmail("deepak@mail.com")
                .setAge(22)
                .build();


üß© How Builder Improves Code
******************************
‚û§ Readable: Field names appear during object creation
‚û§ Flexible: Optional fields can be ignored
‚û§ Immutable: Object built is final
‚û§ Clean API: No messy constructors
‚û§ Scalable: Easy to add new fields

üß© When to Use Builder Pattern?
*********************************
‚û§ When object has more than 4‚Äì5 parameters
‚û§ When object has optional parameters
‚û§ When object construction should be controlled step-by-step
‚û§ When creating immutable objects
‚û§ When construction logic is complex

üß© Advantages
**************
‚û§ Avoids telescoping constructors
‚û§ Increased readability
‚û§ Helps create immutable objects
‚û§ Cleaner and maintainable code
‚û§ Flexibility in object creation

üß© Disadvantages
*******************
‚û§ More code due to builder class
‚û§ Slightly more memory usage
‚û§ More classes to manage

üß© Builder vs Factory vs Constructor (Interview Favorite)
*************************************************************
‚û§ Constructor:
‚û§ Simple, use when parameters < 3

‚û§ Factory:
‚û§ Decides which object to create

‚û§ Builder:
‚û§ Decides how to construct the object step-by-step

üß© Real-World Examples in Java
********************************
‚û§ StringBuilder, StringBuffer (similar idea)
‚û§ java.lang.ProcessBuilder
‚û§ Lombok @Builder
‚û§ Stream.Builder<T>
‚û§ Calendar.Builder

üß© Common Interview Questions
*******************************
‚û§ What is Builder Pattern?
‚û§ Why is it preferred over telescoping constructors?
‚û§ Difference between Builder and Factory?
‚û§ Can Builder create immutable objects?
‚û§ Describe the real-world examples of Builder.
‚û§ Is Builder a creational or structural pattern?

#############################
üß© Decorator Design Pattern 
#############################
üß© Definition
***************
‚û§ The Decorator Pattern is a Structural Design Pattern used to add new functionalities to an object dynamically, without modifying its original class.
‚û§ Decorators wrap an object and add extra behavior before/after delegating calls to the original object.

üß© Intent (Why Decorator Pattern?)
************************************
‚û§ To extend functionality dynamically at runtime.
‚û§ To avoid subclass explosion (too many subclasses for combinations of features).
‚û§ To add responsibilities to an object without changing existing code (follows OCP).
‚û§ To decorate (wrap) an object with additional features.

üß© Real-World Examples
*************************
‚û§ Java I/O Streams
‚û§ BufferedInputStream wraps FileInputStream
‚û§ DataInputStream, BufferedReader, ZipInputStream
‚û§ Spring Boot Filters (decorating request/response)
‚û§ Adding toppings to pizza (Cheese, Peppers, Olives)
‚û§ Text formatting (bold, italic, underline decorators)
‚û§ Logging wrappers
‚û§ Enhancing service layer with cache/log decorators

üß© Where to Use Decorator Pattern?
************************************
‚û§ When you want to add new behaviors to objects dynamically
‚û§ When subclassing is impractical due to too many combinations
‚û§ When you want to follow Open/Closed Principle
‚û§ When you want to wrap a class with extra logic

üß© Key Characteristics (Must Know for Interviews)
***************************************************
‚û§ Uses composition (wrap object) instead of inheritance.
‚û§ Decorator HAS the same interface as the original component.
‚û§ New behavior can be added before/after delegating calls.
‚û§ Multiple decorators can be stacked.
‚û§ Helps avoid too many subclasses.

üß© Structure (UML Overview)
*****************************
‚û§ Component (Interface)
‚û§ Base interface for both core objects and decorators

‚û§ Concrete Component
‚û§ Actual object you want to decorate

‚û§ Decorator (Abstract class)
‚û§ Implements Component and has a reference to the wrapped Component

‚û§ Concrete Decorators
‚û§ Add new behavior

‚û§ Client
‚û§ Wraps objects with decorators

üß© Java Example ‚Äî Coffee Shop (Classic Decorator Example)
**********************************************************
1Ô∏è‚É£ Component Interface
=========================
public interface Coffee {
    String getDescription();
    double getCost();
}

2Ô∏è‚É£ Concrete Component
======================
public class BasicCoffee implements Coffee {
    public String getDescription() {
        return "Basic Coffee";
    }
    public double getCost() {
        return 50;
    }
}

3Ô∏è‚É£ Decorator (Abstract)
=========================
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

4Ô∏è‚É£ Concrete Decorators
========================
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }
    public double getCost() {
        return coffee.getCost() + 10;
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    public String getDescription() {
        return coffee.getDescription() + ", Sugar";
    }
    public double getCost() {
        return coffee.getCost() + 5;
    }
}

5Ô∏è‚É£ Client Code
===============
public class Main {
    public static void main(String[] args) {
        Coffee coffee = new BasicCoffee();
        coffee = new MilkDecorator(coffee);
        coffee = new SugarDecorator(coffee);

        System.out.println(coffee.getDescription());
        System.out.println("Cost: " + coffee.getCost());
    }
}

Output:
Basic Coffee, Milk, Sugar
Cost: 65.0


üß© Advantages
**************
‚û§ Add functionality at runtime
‚û§ No need to modify existing code
‚û§ Flexible ‚Äî combine decorators in any order
‚û§ Avoids class explosion
‚û§ Follows Open/Closed Principle & Single Responsibility Principle

üß© Disadvantages
******************
‚û§ Many small classes (one per decorator)
‚û§ Debugging can be tricky due to multiple wrapping layers
‚û§ Order of decorators matters
‚û§ Complexity increases if too many decorators are used

üß© Decorator vs Inheritance (Interview Favorite)
**************************************************
‚û§ Inheritance
‚û§ Static behavior
‚û§ Compile-time
‚û§ Adds functionality to entire class

‚û§ Decorator
‚û§ Dynamic behavior
‚û§ Runtime
‚û§ Adds functionality to a single object instance

üß© Decorator vs Chain of Responsibility
******************************************
‚û§ Decorator
‚û§ All decorators execute
‚û§ Used to enhance (add behavior)

‚û§ CoR
‚û§ Only one handler might handle
‚û§ Used to pass request along a chain

üß© Common Interview Questions
******************************
‚û§ What is Decorator Pattern?
‚û§ How is it used in Java I/O?
‚û§ Difference between Decorator and Adapter?
‚û§ Decorator vs Inheritance?
‚û§ Can decorators be nested?
‚û§ Real-life example?

############################
üß© Adapter Design Pattern 
############################
üß© Definition
****************
‚û§ The Adapter Pattern is a Structural Design Pattern that allows two incompatible interfaces to work together.
‚û§ It acts as a bridge between an existing class and a client that expects a different interface.

‚û§ In simple words:
Adapter converts one interface into another interface expected by the client.

üß© Intent (Why Adapter Pattern?)
***********************************
‚û§ To reuse old/existing code with a new system without modifying it.
‚û§ To allow incompatible classes to communicate.
‚û§ To wrap a class with a different interface that the client understands.
‚û§ To follow Open/Closed Principle ‚Äî extend behavior without modifying existing code.

üß© Real-World Examples
***********************
‚û§ Mobile charger adapter ‚Äî Converts 220V to 5V
‚û§ Card reader ‚Äî SD card to USB
‚û§ HDMI-to-VGA converter
‚û§ Java Collections API
‚û§ Arrays.asList() ‚Üí Adapts array to List
‚û§ Spring Web
‚û§ HandlerAdapter allows controllers of different types to work
‚û§ Legacy system integration

üß© When to Use Adapter Pattern?
**********************************
‚û§ When you want to use an existing class but its interface does not match your requirements.
‚û§ When you want to integrate new code with a legacy system.
‚û§ When you need to convert data formats or APIs.
‚û§ When you follow the ‚Äúdon‚Äôt modify existing code‚Äù principle.

üß© Types of Adapter
*********************
‚û§ Object Adapter (Most common)
‚û§ Uses composition
‚û§ Adapter contains the adaptee object

‚û§ Class Adapter
‚û§ Uses inheritance
‚û§ Adapter inherits from Adaptee (not common in Java because Java doesn‚Äôt support multiple inheritance)

üß© Structure (UML Essentials)
*******************************
‚û§ Target Interface ‚Üí What client expects
‚û§ Adaptee ‚Üí Class with incompatible interface
‚û§ Adapter ‚Üí Converts the request to the Adaptee‚Äôs format
‚û§ Client ‚Üí Uses Target interface

üß© Java Example ‚Äî Adapter Pattern (Mobile Charger Analogy)
*************************************************************
1Ô∏è‚É£ Target Interface (What client expects)
===========================================
public interface Charger {
    void chargePhone();
}

2Ô∏è‚É£ Adaptee (Existing incompatible class)
==========================================
public class HomeSocket {
    public void provideElectricity() {
        System.out.println("Providing 240V electricity");
    }
}

3Ô∏è‚É£ Adapter (Converts 240V ‚Üí 5V)
================================
public class ChargerAdapter implements Charger {
    private HomeSocket socket;

    public ChargerAdapter(HomeSocket socket) {
        this.socket = socket;
    }

    @Override
    public void chargePhone() {
        System.out.println("Adapter converting 240V to 5V...");
        socket.provideElectricity();
        System.out.println("Phone is charging safely");
    }
}

4Ô∏è‚É£ Client Code
===============
public class Main {
    public static void main(String[] args) {
        HomeSocket socket = new HomeSocket();
        Charger charger = new ChargerAdapter(socket);
        charger.chargePhone();
    }
}

Output
Adapter converting 240V to 5V...
Providing 240V electricity
Phone is charging safely

üß© Advantages
****************
‚û§ Reuse existing code without modifying it
‚û§ Improves reusability
‚û§ Increases compatibility between old and new code
‚û§ Supports Open/Closed Principle
‚û§ Flexible ‚Äî you can wrap many adapters around the same adaptee

üß© Disadvantages
******************
‚û§ Adds extra layer ‚Äî may increase complexity
‚û§ Too many adapters can make the system hard to understand
‚û§ Not suitable if you can modify the existing class ‚Äî in that case, refactoring is simpler

üß© Adapter vs Decorator vs Proxy
************************************
‚û§ Adapter ‚Üí Converts interface
‚û§ Decorator ‚Üí Adds new behavior
‚û§ Proxy ‚Üí Controls access (security, lazy load, logging)

üß© Real Java Examples
***********************
‚û§ Arrays.asList()
‚û§ InputStreamReader(InputStream)
‚û§ ResourceAdapter in Spring
‚û§ JDBC driver wrappers
‚û§ Log4j to SLF4J bridges

üß© Common Interview Questions
********************************
‚û§ What is Adapter Pattern?
‚û§ Difference between Class Adapter and Object Adapter?
‚û§ How is Adapter used in Java I/O?
‚û§ Adapter vs Decorator vs Proxy?
‚û§ Give real-time example of Adapter in your project.
‚û§ How does Adapter follow OCP?

############################
üß© Iterator Design Pattern
############################
‚û§ Definition
**************
The Iterator pattern provides a standard way to sequentially access elements of a collection without exposing its internal structure.

üß© Key Points
****************
‚û§ Type: Behavioral Pattern
‚û§ Focus: Traverse collections (List, Set, Trees, Custom collections) in a uniform way
‚û§ Goal: Hide the complexity/structure of the underlying data representation

üß© Intent
***********
‚û§ Provide a common interface to iterate over a collection.
‚û§ Allow multiple types of iteration (forward, backward, custom traversal).
‚û§ Decouple traversal logic from collection class.

üß© Where It Is Used in Java
******************************
‚û§ Java‚Äôs Iterator, ListIterator, Iterable interfaces.
‚û§ Enhanced for-loop (for (int x : list)) internally uses Iterator.
‚û§ Collection classes (ArrayList, HashSet, LinkedList) all use it.

üß© Structure (Conceptual)
***************************
‚û§ Iterator
‚ÄÉ‚û§ Provides operations like hasNext() and next()
‚û§ ConcreteIterator
‚ÄÉ‚û§ Implements iteration over a specific collection
‚û§ Aggregate / Iterable
‚ÄÉ‚û§ Creates an iterator
‚û§ ConcreteAggregate
‚ÄÉ‚û§ Returns an iterator for the collection

üß© Simple Java Example
*************************
Collection (Aggregate)
interface Container {
    Iterator getIterator();
}

Iterator Interface
interface Iterator {
    boolean hasNext();
    Object next();
}

Concrete Collection
class NameRepository implements Container {
    private String[] names = { "John", "David", "Sara" };

    @Override
    public Iterator getIterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator {
        int index = 0;

        @Override
        public boolean hasNext() {
            return index < names.length;
        }

        @Override
        public Object next() {
            return hasNext() ? names[index++] : null;
        }
    }
}

Usage
NameRepository repo = new NameRepository();
Iterator it = repo.getIterator();

while (it.hasNext()) {
    System.out.println(it.next());
}

üß© Real-World Examples
************************
‚û§ TV remote channels ‚Äî press next/previous without knowing stored channel list
‚û§ Music playlist ‚Äî iterate songs sequentially
‚û§ Browser history ‚Äî go forward/backward

üß© Advantages
****************
‚û§ Uniform traversal across different collections
‚û§ Encapsulation ‚Äî hides internal structure
‚û§ Multiple iteration algorithms possible
‚û§ Supports parallel or custom iterators

üß© Disadvantages
*******************
‚û§ Extra classes (Iterator, ConcreteIterator) increase complexity
‚û§ Multiple iterators on the same collection may cause concurrency issues

üß© When to Use
***************
‚û§ You want to iterate without exposing internal data structure.
‚û§ You want to support multiple traversal types (reverse, filtered, custom).
‚û§ You want clean separation between collection and traversal logic.

üß© Interview Questions
************************
‚û§ Why do we need Iterator when we have simple loops?
‚û§ Difference between Iterator and ListIterator?
‚û§ Why is Iterator.remove() preferred over modifying during iteration?
‚û§ Fail-fast vs Fail-safe iterator in Java?
‚û§ Internal working of foreach loop in Java?

############################
üß© Observer Design Pattern
############################
‚û§ Definition
**************
The Observer Pattern defines a one-to-many dependency between objects so that when one object (Subject) changes its state, all its dependents (Observers) are notified automatically.

üß† Why Is It Used? (Intent)
*****************************
‚û§ To achieve loose coupling between objects.
‚û§ To ensure automatic updates to subscribers when the data changes.
‚û§ To support event-driven systems.

üîß Where Is It Used? (Real-Life Examples)
*********************************************
‚û§ YouTube Subscription ‚Üí When a channel uploads a video, all subscribers get notified.
‚û§ Stock Market Apps ‚Üí Investors get alerts when stock price changes.
‚û§ GUI Listeners ‚Üí Button click listeners, keypress listeners.
‚û§ Weather App Updates.

üèóÔ∏è Core Components
********************
‚û§ Subject (Observable)
üëâ Stores the list of observers
üëâ Notifies observers on state change

‚û§ Observer
üëâ Gets updates from the subject
üëâ Defines the update() method

‚û§ Concrete Subject
üëâ Implements maintaining & notifying observers

‚û§ Concrete Observer
üëâ Reacts to subject updates

üß± UML Structure (Simple View)
*********************************
Subject --------> Observer
  |                 ‚Üë
  | notify()        |
  | add/remove      |
ConcreteSubject     |
  | state           |
ConcreteObserver ----

üíª Java Example (Note-Making Friendly)
***************************************
1. Observer Interface
======================
interface Observer {
    void update(String message);
}

2. Subject Interface
======================
interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}

3. Concrete Subject
====================
class YouTubeChannel implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String latestVideo;

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        observers.remove(o);
    }

    @Override
    public void notifyObservers() {
        for (Observer o : observers) {
            o.update(latestVideo);
        }
    }

    public void uploadVideo(String title) {
        this.latestVideo = title;
        notifyObservers();
    }
}

4. Concrete Observer
=====================
class Subscriber implements Observer {
    private String name;

    public Subscriber(String name) {
        this.name = name;
    }

    @Override
    public void update(String video) {
        System.out.println(name + " got notified: New video uploaded -> " + video);
    }
}

5. Test
========
public class Main {
    public static void main(String[] args) {
        YouTubeChannel channel = new YouTubeChannel();

        Observer s1 = new Subscriber("Deepak");
        Observer s2 = new Subscriber("Aman");

        channel.registerObserver(s1);
        channel.registerObserver(s2);

        channel.uploadVideo("Design Patterns in Java!!!");
    }
}

‚≠ê When To Use Observer Pattern
*********************************
‚û§ When multiple objects depend on another object‚Äôs state
‚û§ When you want event-driven architecture
‚û§ When you want loose coupling between broadcaster and listeners

‚úÖ Advantages
**************
‚û§ Loose coupling
‚û§ Easy to add new observers
‚û§ Supports event-driven programming
‚û§ Subject doesn‚Äôt need to know observer details

‚ùå Disadvantages
******************
‚û§ Too many notifications can cause performance overhead
‚û§ Observers might depend on update order
‚û§ Hard to debug due to complex chains

üéØ Interview Questions (Most Asked!)
**************************************
‚û§ What is the observer pattern and where is it used?
‚û§ Difference between Observer and Publish-Subscribe?
üëâ Pub-Sub uses broker; Observer does not.
üëâ In Observer, subject knows observers directly.

‚û§ Is Observer pattern synchronous or asynchronous?
üëâ Classic implementation = synchronous
üëâ Can be async using event queues

‚û§ Which design principle does it follow?
üëâ Follows Open-Closed Principle
üëâ Follows Loose Coupling Principle

###################################
üß© Template Method Design Pattern
###################################
‚û§ Definition:
***************
The Template Method is a behavioral design pattern that defines the skeleton (template) of an algorithm in a base class and allows subclasses to override specific steps of the algorithm without changing its structure.

‚û§ Simple Meaning:
==================
Parent class = defines steps
Child class = customizes only required steps
Algorithm flow = fixed + controlled

üß© Intent / Purpose
*********************
‚û§ Define the fixed flow of an operation once, while allowing subclasses to redefine certain steps.
‚û§ Promote code reuse and avoid duplicate algorithm structure.
‚û§ Enforce a consistent algorithm template.

üß© Key Characteristics
************************
‚û§ Algorithm structure is fixed and cannot be changed by subclasses.
‚û§ Subclasses customize steps via abstract or hook methods.
‚û§ Follows Hollywood Principle ‚Äî ‚ÄúDon‚Äôt call us, we‚Äôll call you.‚Äù
‚û§ Defines a template method (final) in the parent class.

üß© Structure (UML-like)
*************************
AbstractClass
   ‚îú‚îÄ‚îÄ templateMethod()  ‚Üí final (algorithm steps)
   ‚îú‚îÄ‚îÄ step1() ‚Üí abstract
   ‚îú‚îÄ‚îÄ step2() ‚Üí abstract
   ‚îî‚îÄ‚îÄ hook()  ‚Üí optional override

ConcreteClassA / ConcreteClassB
   ‚îú‚îÄ‚îÄ implement step1()
   ‚îî‚îÄ‚îÄ implement step2()

üß© Real-Life Analogy
**********************
Making Tea vs Coffee
‚û§ Boil water (same)
‚û§ Add ingredients (different)
‚û§ Pour and serve (same)

The skeleton stays the same, but specific steps differ.

üß© Java Example (Interview-Ready)
************************************
Step 1: Create Template 
-------------------------
abstract class DataProcessor {

    // Template method (the algorithm)
    public final void process() {
        readData();
        processData();
        saveData();
        hook();        // optional customization
    }

    abstract void readData();
    abstract void processData();

    void saveData() {
        System.out.println("Saving processed data...");
    }

    // Hook method ‚Äì optional
    void hook() {}
}

Step 2: Concrete Classes
-------------------------
class CSVDataProcessor extends DataProcessor {

    void readData() {
        System.out.println("Reading CSV data");
    }

    void processData() {
        System.out.println("Processing CSV data");
    }
}

class JSONDataProcessor extends DataProcessor {

    void readData() {
        System.out.println("Reading JSON data");
    }

    void processData() {
        System.out.println("Processing JSON data");
    }

    // Optional hook override
    void hook() {
        System.out.println("Validating JSON data");
    }
}

Step 3: Client 
----------------
public class Main {
    public static void main(String[] args) {
        DataProcessor processor = new CSVDataProcessor();
        processor.process();

        processor = new JSONDataProcessor();
        processor.process();
    }
}

üß© When to Use Template Method
*********************************
‚û§ When multiple classes share the same algorithm structure.
‚û§ When certain steps should be customizable, but the sequence must remain the same.
‚û§ When you want to avoid duplicate code for algorithm flow.
‚û§ When you want to have hooks for optional behavior.

üß© Advantages
***************
‚û§ Promotes code reuse and clean architecture.
‚û§ Reduces duplicate logic.
‚û§ Ensures algorithm consistency across implementations.
‚û§ Extensible ‚Äî child classes customize only required steps.

üß© Disadvantages
*******************
‚û§ More subclasses = more complexity.
‚û§ Changes in base algorithm affect all subclasses.
‚û§ Increases tight coupling between base class and subclasses.

üß© Key Interview Questions
*****************************
‚û§ What is the Template Method pattern?
‚û§ Why is the template method declared final?
‚û§ What are hook methods?
‚û§ Difference between template method and strategy pattern?
‚û§ Real-world example in Java libraries?

üß© Real Examples in Java
***************************
‚û§ java.io.InputStream, java.io.OutputStream ‚Üí read(), write() methods.
‚û§ javax.servlet.http.HttpServlet ‚Üí doGet(), doPost() methods.
‚û§ Spring Framework uses templates (e.g., JdbcTemplate, RestTemplate).

##############################
üß© Prototype Design Pattern 
##############################
The Prototype Pattern is a creational design pattern used when creating objects is costly, heavy, or complex, and you want to clone existing objects instead of creating new ones from scratch.

üß© Definition
***************
‚û§ Prototype pattern allows you to create new objects by copying (cloning) existing objects.
‚û§ Instead of instantiating new objects using new, you clone a prototype, which acts as a template.

üß© Why Do We Need It?
***********************
‚û§ When creating an object is:

üëâ Expensive (e.g., connecting to DB, loading a file)

üëâ Complicated (many steps/configurations)

üëâ Time-consuming (e.g., parsing XML/JSON every time)

‚û§ Cloning avoids that overhead by copying an already prepared object.

üß© Real-Life Analogy
***********************
‚û§ Think of a notary stamping documents.
Instead of writing a fresh document every time, the notary keeps a master copy and makes xerox copies (clones) whenever someone needs one.

üß© Structure
***************
‚û§ Prototype interface ‚Üí declares the clone() method
‚û§ Concrete Prototype ‚Üí class that implements cloning
‚û§ Client ‚Üí asks for a clone instead of creating a new object

üß© Types of Cloning
‚û§ Shallow Copy

üëâ Copies only object references
üëâ Nested objects are shared

‚û§ Deep Copy

üëâ Copies everything
üëâ Nested objects are also duplicated

üß© Java Example (Simple & Easy)
**********************************
üîπ Step 1: Create Prototype Interface
-----------------------------------------
public interface Prototype {
    Prototype clone();
}

üîπ Step 2: Concrete Prototype Class
-------------------------------------
public class Employee implements Prototype {
    private String name;
    private String department;

    public Employee(String name, String department) {
        this.name = name;
        this.department = department;
    }

    @Override
    public Prototype clone() {
        return new Employee(name, department);   // deep copy
    }

    @Override
    public String toString() {
        return name + " - " + department;
    }
}

üîπ Step 3: Client
-------------------
public class Main {
    public static void main(String[] args) {
        Employee emp1 = new Employee("Deepak", "Backend");
        
        Employee emp2 = (Employee) emp1.clone(); // cloning

        System.out.println(emp1);
        System.out.println(emp2);
    }
}

üß© When to Use Prototype Pattern?
************************************
‚û§ When object creation is expensive or slow
‚û§ When the system should be independent of the object creation logic
‚û§ When you want to avoid subclassing just to create multiple object configurations
‚û§ When you need multiple similar objects quickly

üß© Advantages
****************
‚û§ Fast object creation
‚û§ Avoids repetitive complex construction
‚û§ Reduces memory usage
‚û§ Less boilerplate than Factory/Builder in some cases

üß© Disadvantages
******************
‚û§ Deep cloning can be complex
‚û§ You must handle circular references
‚û§ Not suitable if the object contains external resources (e.g., DB connections)

üß© Interview-Ready Points
***************************
‚û§ Prototype pattern clones existing objects, reducing object creation cost
‚û§ Uses clone() method
‚û§ Supports shallow and deep copying
‚û§ Used when objects have complex initialization
‚û§ Common in:
üëâ Game engines (cloning characters)
üëâ Document editors (copy/paste)
üëâ Frameworks requiring fast duplication

####################################
üß© Abstract Factory Design Pattern
####################################
üß© What is the Abstract Factory Pattern?
******************************************
‚û§ The Abstract Factory Pattern is a creational design pattern that provides an interface to create families of related objects without specifying their concrete classes.
‚û§ It is basically a factory of factories ‚Äî each factory creates related objects.

üß© Why Do We Use It?
**********************
‚û§ When your system needs to create a set of related objects.
‚û§ When you want consistency among products (e.g., UI themes, OS-specific components).
‚û§ When you want to decouple object creation from usage.

üß© Real-Life Analogy
*********************
‚û§ Think of a Furniture Store that sells:
    üëâ Modern Chair, Modern Sofa
    üëâ Victorian Chair, Victorian Sofa
‚û§ You first choose the factory (Modern Factory / Victorian Factory), and then you get related products.
‚û§ Each factory produces a family of consistent products.

üß© Structure
***************
‚û§ AbstractFactory ‚Üí Interface with methods to create product families.
‚û§ ConcreteFactory ‚Üí Implements object creation.
‚û§ AbstractProduct ‚Üí Interface for product.
‚û§ ConcreteProduct ‚Üí Actual implementation.
‚û§ Client ‚Üí Uses the factory but never knows the actual classes.

üß© Code Example (Java)
************************
üéØ Goal: Create UI based on OS (Windows or Mac)
=================================================
// Abstract Product A
interface Button {
    void click();
}

// Abstract Product B
interface Checkbox {
    void check();
}

// Concrete Product A1
class WindowsButton implements Button {
    public void click() {
        System.out.println("Windows Button Clicked");
    }
}

// Concrete Product A2
class MacButton implements Button {
    public void click() {
        System.out.println("Mac Button Clicked");
    }
}

// Concrete Product B1
class WindowsCheckbox implements Checkbox {
    public void check() {
        System.out.println("Windows Checkbox Checked");
    }
}

// Concrete Product B2
class MacCheckbox implements Checkbox {
    public void check() {
        System.out.println("Mac Checkbox Checked");
    }
}

// Abstract Factory
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Concrete Factory 1
class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

// Concrete Factory 2
class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

// Client
class Application {
    private Button button;
    private Checkbox checkbox;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }

    public void render() {
        button.click();
        checkbox.check();
    }
}

// Test
public class Main {
    public static void main(String[] args) {
        GUIFactory factory = new WindowsFactory(); // or MacFactory()
        Application app = new Application(factory);
        app.render();
    }
}

üß© Advantages
****************
‚û§ Ensures compatibility among created objects.
‚û§ Code becomes more flexible and decoupled.
‚û§ Makes adding new product families easy.

üß© Disadvantages
*****************
‚û§ Adding new products (e.g., adding Slider component) requires modifying all factories.
‚û§ Increases number of classes.

üß© When to Use Abstract Factory?
*********************************
‚û§ When products are created in groups/families.
‚û§ When system must not depend on product concrete classes.
‚û§ When you need runtime selection of the product family.

##########################
üß© Facade Design Pattern
##########################
The Facade Pattern is a structural design pattern that provides a simple, unified interface to a complex subsystem.
It hides complexity and exposes only what is necessary.

üìù Definition
***************
‚û§ Facade pattern wraps complex libraries, frameworks, or multiple classes behind a single class
‚û§ That single class becomes a gateway for the client
‚û§ Client does not need to know the internals ‚Äî only calls simple methods

üéØ Why Use Facade Pattern?
*****************************
‚û§ To reduce complexity when working with multiple dependent classes
‚û§ To improve readability & maintainability
‚û§ To decouple the client from the complex subsystem
‚û§ To avoid exposing unnecessary internal logic

üéÆ Real-Life Analogy (Very Easy)
***********************************
üëâ TV Remote
==============
Without a remote, you must manually operate TV, Set-top box, Home theatre, DVD Player, etc.
Remote provides only simple buttons ‚Üí ON, OFF, Volume, Channel

It hides all complex circuits.

üîß Example (Simple Java Code)
******************************
üé¨ Subsystem classes (complex system)
---------------------------------------
class AudioSystem {
    void on() { System.out.println("Audio ON"); }
    void off() { System.out.println("Audio OFF"); }
}

class Projector {
    void on() { System.out.println("Projector ON"); }
    void off() { System.out.println("Projector OFF"); }
}

class Screen {
    void down() { System.out.println("Screen Down"); }
    void up() { System.out.println("Screen Up"); }
}

üéØ Facade class
------------------
class HomeTheatreFacade {

    private AudioSystem audio;
    private Projector projector;
    private Screen screen;

    public HomeTheatreFacade(AudioSystem audio, Projector projector, Screen screen) {
        this.audio = audio;
        this.projector = projector;
        this.screen = screen;
    }

    public void watchMovie() {
        screen.down();
        projector.on();
        audio.on();
        System.out.println("Movie Started!");
    }

    public void endMovie() {
        audio.off();
        projector.off();
        screen.up();
        System.out.println("Movie Ended!");
    }
}

üéÆ Client (simple interaction)
--------------------------------
class Main {
    public static void main(String[] args) {
        HomeTheatreFacade theatre = new HomeTheatreFacade(
            new AudioSystem(),
            new Projector(),
            new Screen()
        );

        theatre.watchMovie();
        theatre.endMovie();
    }
}

üí° When to Use?
*****************
‚û§ When you want to hide complex logic behind simple APIs
‚û§ When working with third-party libraries
‚û§ When dealing with legacy systems
‚û§ When client should be independent of subsystem complexities

üß† Key Interview Points
************************
‚û§ Facade simplifies API by providing a single entry point
‚û§ It does not restrict access ‚Äî subsystem classes are still accessible
‚û§ It reduces coupling between client and subsystem
‚û§ It is different from Adapter ‚Äî
üëâ Adapter changes interface
üëâ Facade simplifies interface
‚û§ Mostly used in frameworks (Spring, Hibernate)

#########################
üß© Proxy Design Pattern
#########################
üéØ Definition
**************
‚û§ The Proxy Pattern provides a surrogate/placeholder object for another object to control access, add extra functionality, or delay expensive operations without modifying the real object.

‚≠ê Why Proxy?
***************
‚û§ Sometimes the real object is
üëâ heavy,
üëâ slow to create,
üëâ remote,
üëâ sensitive (needs security),
üëâ or needs logging/caching.

‚û° In such cases, a Proxy stands in front and manages access.

üß© How It Works
*****************
‚û§ Subject Interface
üëâ Common interface implemented by both Real Object & Proxy.

‚û§ Real Subject
üëâ The actual business object.

‚û§ Proxy
üëâ Controls access to Real Subject
üëâ Adds extra logic: caching, logging, security checks, lazy loading, etc.

üß© Real-World Examples
************************
‚úî ATM Card ‚Üí Proxy for Bank Account

‚û§ You don't directly access your bank account
‚û§ ATM card acts like a proxy adding
üëâ Security
üëâ Validation
üëâ Access control

‚úî YouTube Video Thumbnail ‚Üí Proxy

‚û§ Actual video is large ‚Üí expensive to load
‚û§ Thumbnail loads instantly ‚Üí virtual proxy

‚úî Internet Firewall ‚Üí Protection Proxy

üëâ Controls which sites you can access

üß© Types of Proxy
*******************
‚û§ 1. Virtual Proxy
=====================
üëâ Used for expensive objects (e.g., load an image only when needed).

‚û§ 2. Protection Proxy
=======================
üëâ Controls access based on permissions/security.

‚û§ 3. Remote Proxy
==================
üëâ Represents an object located on another JVM/server (RMI, microservices).

‚û§ 4. Smart Proxy
==================
üëâ Adds extra behavior like logging, caching, reference counting.

üß© Code Example (Java)
************************
‚û° Virtual Proxy Example ‚Äî Loading heavy image
===============================================
1. Subject Interface
---------------------
public interface Image {
    void display();
}

2. Real Subject
-----------------
public class RealImage implements Image {
    private String fileName;

    public RealImage(String fileName) {
        this.fileName = fileName;
        loadFromDisk(); 
    }

    private void loadFromDisk() {
        System.out.println("Loading " + fileName);
    }

    @Override
    public void display() {
        System.out.println("Displaying " + fileName);
    }
}

3. Proxy Class
---------------
public class ProxyImage implements Image {
    private RealImage realImage;
    private String fileName;

    public ProxyImage(String fileName) {
        this.fileName = fileName;
    }

    @Override
    public void display() {
        if(realImage == null) {
            realImage = new RealImage(fileName);  
        }
        realImage.display();
    }
}

4. Client
------------
public class Client {
    public static void main(String[] args) {
        Image image = new ProxyImage("photo.png");

        System.out.println("First call:");
        image.display();    

        System.out.println("Second call:");
        image.display();    
    }
}

Output
First call:
Loading photo.png
Displaying photo.png

Second call:
Displaying photo.png


‚úî First display loads the image
‚úî Second display uses cached RealImage ‚Üí faster

üß© When to Use Proxy Pattern?
*******************************
‚û§ When object creation is expensive
‚û§ When you want to control access
‚û§ When you need lazy loading
‚û§ When you want logging, caching, validation
‚û§ When the real object is remote/inaccessible

üß© Advantages
****************
‚û§ Adds extra functionality without changing original code
‚û§ Supports lazy loading
‚û§ Improves performance & security
‚û§ Helps in distributed systems

üß© Disadvantages
******************
‚û§ Adds an extra layer ‚Üí slightly more complex
‚û§ More classes ‚Üí increased maintenance

###########################
üß© Memento Design Pattern
###########################
‚≠ê Definition
****************
‚û§ The Memento Design Pattern is a behavioral design pattern that lets you
restore an object‚Äôs state to a previous state without exposing its internal details.

‚û§ It provides undo/rollback functionality just like in text editors, games, forms, etc.

üéØ Intent
***********
‚û§ Capture an object‚Äôs internal state
‚û§ Store it outside the object without violating encapsulation
‚û§ Restore it later when needed

üéÆ Real-Life Analogy
**********************
‚û§ Think of a game checkpoint:
üëâ When you reach a checkpoint, the game saves your progress (memento).
üëâ If you die, you load the checkpoint (restore state).
üëâ The game doesn‚Äôt expose internal variables like health, coins, position.

üèóÔ∏è Participants
*******************
1Ô∏è‚É£ Originator
===============
‚û§ The object whose state needs to be saved.
‚û§ Creates mementos and restores from mementos.

2Ô∏è‚É£ Memento
============
‚û§ Stores the internal state of the originator.
‚û§ No setters ‚Üí ensures encapsulation.

3Ô∏è‚É£ Caretaker
=============
‚û§ Stores the mementos.
‚û§ Doesn‚Äôt modify or inspect mementos.
‚û§ Responsible for maintaining rollback history.

üì¶ When to Use
****************
‚û§ You need an undo/redo mechanism
‚û§ You want to save object state without breaking encapsulation
‚û§ You want to implement versioning or checkpoints

üë®‚Äçüíª Example (Java Code)
***********************
Originator
----------
class Editor {
    private String content;

    public void setContent(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }

    public EditorMemento save() {
        return new EditorMemento(content);
    }

    public void restore(EditorMemento memento) {
        this.content = memento.getContent();
    }
}

Memento
--------
class EditorMemento {
    private final String content;

    public EditorMemento(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }
}

Caretaker
----------
class History {
    private Stack<EditorMemento> history = new Stack<>();

    public void push(EditorMemento memento) {
        history.push(memento);
    }

    public EditorMemento pop() {
        return history.pop();
    }
}

Usage
------
public class MementoDesignPatternExample {
    public static void main(String[] args) {
        Editor editor = new Editor();
        History history = new History();

        editor.setContent("A");
        history.push(editor.save());

        editor.setContent("B");
        history.push(editor.save());

        editor.setContent("C");

        editor.restore(history.pop());
        System.out.println(editor.getContent()); // Output: B

        editor.restore(history.pop());
        System.out.println(editor.getContent()); // Output: A
    }
}

üí° Key Points (Interview-Friendly)
************************************
‚û§ Provides undo/rollback functionality.
‚û§ Protects encapsulation ‚Äî internal details are not exposed.
‚û§ Caretaker stores the mementos but doesn‚Äôt modify them.
‚û§ Originator creates and restores from mementos.
‚û§ Best for editors, games, transactions, UI states.

################################################
üß© Bridge Design Pattern (Structural Pattern)
################################################
The Bridge Pattern is used to decouple an abstraction from its implementation so that both can evolve independently.

üß© Why Bridge Pattern?
************************
‚û§ When you have two dimensions of change in a system:
üëâ Example: Shape (Circle, Square) and Color (Red, Blue).
If you try to combine them using inheritance, you‚Äôll end up with classes like:
‚û§ RedCircle
‚û§ BlueCircle
‚û§ RedSquare
‚û§ BlueSquare
This explodes into MANY subclasses ‚Üí Complex + Hard to maintain.

Bridge solves this.

üß© Definition
**************
‚û§ Separates Abstraction (what to do) from Implementation (how to do) by placing them in different class hierarchies.

üß© Real-Life Analogy
*********************
‚û§ TV Remote
üëâ Remote = Abstraction
üëâ TV Brand (Sony, LG, Samsung) = Implementation
Same remote buttons work with any brand because remote and TV are loosely coupled.

üß© Structure
**************
‚û§ Abstraction Layer
‚û§ High-level control
‚û§ Holds reference to Implementation (bridge)
‚û§ Implementation Layer
‚û§ Low-level operations
‚û§ Different concrete implementations
‚û§ Abstraction ‚Üí Implementor ‚Üí ConcreteImplementor

üß© UML 
********
        Abstraction
            |
      Ref to Implementor  <---- Bridge
            |
      -----------------
      |               |
RefinedAbstraction   Implementor (interface)
                          |
                 ----------------------
                 |                    |
       ConcreteImplementorA   ConcreteImplementorB

üß© Java Example (Easy & Clear)
*********************************
üéØ Goal ‚Üí Draw shapes with different colors
‚û§ Instead of creating many subclasses, we separate Shape & Color.

1Ô∏è‚É£ Implementor (Color interface)
---------------------------------
interface Color {
    void applyColor();
}

2Ô∏è‚É£ Concrete Implementors
--------------------------
class RedColor implements Color {
    public void applyColor() {
        System.out.println("Applying Red Color");
    }
}

class BlueColor implements Color {
    public void applyColor() {
        System.out.println("Applying Blue Color");
    }
}

3Ô∏è‚É£ Abstraction (Shape)
------------------------
abstract class Shape {
    protected Color color;

    Shape(Color color) {
        this.color = color;
    }

    abstract void draw();
}

4Ô∏è‚É£ Refined Abstraction
------------------------
class Circle extends Shape {
    Circle(Color color) {
        super(color);
    }

    public void draw() {
        System.out.print("Drawing Circle ‚Üí ");
        color.applyColor();
    }
}

class Square extends Shape {
    Square(Color color) {
        super(color);
    }

    public void draw() {
        System.out.print("Drawing Square ‚Üí ");
        color.applyColor();
    }
}

5Ô∏è‚É£ Client Code
-----------------
public class BridgePatternDemo {
    public static void main(String[] args) {
        Shape redCircle = new Circle(new RedColor());
        Shape blueSquare = new Square(new BlueColor());

        redCircle.draw();
        blueSquare.draw();
    }
}

üß© Output
------------
Drawing Circle ‚Üí Applying Red Color
Drawing Square ‚Üí Applying Blue Color

üß© When to Use Bridge Pattern?
********************************
‚û§ When you have multiple dimensions that vary independently
üëâ Shape + Color
üëâ Device + Remote
üëâ Payment Method + Payment Gateway

‚û§ When subclass explosion happens due to combinations.

üß© Benefits
*************
‚û§ Abstraction & implementation can change independently
‚û§ No class explosion
‚û§ More flexible system
‚û§ Better testability

üß© Interview-Ready Points
****************************
‚û§ Bridge = Composition over Inheritance
‚û§ Helps avoid Cartesian product explosion of subclasses
‚û§ Used when both Abstraction & Implementor hierarchies vary
‚û§ Makes code scalable and maintainable

###########################################################
üß© State Design Pattern ‚Äî Complete Notes (Interview Ready)
###########################################################
üß© Definition
****************
‚û§ The State Pattern is a Behavioral Design Pattern that allows an object to change its behavior when its internal state changes.
‚û§ The object will appear to change its class at runtime.

‚û§ In simple words:
Behavior depends on the current state, and state-specific behavior is encapsulated in separate classes.

üß© Intent (Why State Pattern?)
*******************************
‚û§ To avoid large if-else or switch statements based on state
‚û§ To make state transitions explicit and manageable
‚û§ To encapsulate state-specific behavior into separate classes
‚û§ To allow behavior change at runtime without changing client code

üß© Real-World Examples
***********************
‚û§ Traffic light system (Red ‚Üí Yellow ‚Üí Green)
‚û§ ATM machine states (Idle, CardInserted, CashWithdrawn)
‚û§ Media player (Playing, Paused, Stopped)
‚û§ Order lifecycle (New, Paid, Shipped, Delivered)
‚û§ TCP connection states
‚û§ Workflow engines

üß© When to Use State Pattern?
********************************
‚û§ When an object has multiple states
‚û§ When behavior changes depending on the state
‚û§ When state transitions are complex
‚û§ When code has many conditionals based on state
‚û§ When you want cleaner, extensible design

üß© Key Characteristics 
************************
‚û§ Each state is represented by a separate class
‚û§ Context object maintains a reference to the current state
‚û§ State transition happens by changing the state object
‚û§ Follows Open/Closed Principle
‚û§ Improves readability and maintainability

üß© Structure (UML Essentials)
******************************
‚û§ State Interface
‚û§ Declares state-specific behavior

‚û§ Concrete States
‚û§ Implement behavior for each state

‚û§ Context
‚û§ Maintains current state
‚û§ Delegates behavior to state object

‚û§ Client
‚û§ Interacts with Context

üß© Java Example ‚Äî Media Player
********************************
1Ô∏è‚É£ State Interface
--------------------
public interface PlayerState {
    void pressPlay(MediaPlayer player);
}

2Ô∏è‚É£ Concrete States
---------------------
public class PlayingState implements PlayerState {
    public void pressPlay(MediaPlayer player) {
        System.out.println("Pausing the music");
        player.setState(new PausedState());
    }
}

public class PausedState implements PlayerState {
    public void pressPlay(MediaPlayer player) {
        System.out.println("Playing the music");
        player.setState(new PlayingState());
    }
}

3Ô∏è‚É£ Context Class
------------------
public class MediaPlayer {
    private PlayerState state;

    public MediaPlayer() {
        state = new PausedState(); // initial state
    }

    public void setState(PlayerState state) {
        this.state = state;
    }

    public void pressPlay() {
        state.pressPlay(this);
    }
}

4Ô∏è‚É£ Client Code
-----------------
public class Main {
    public static void main(String[] args) {
        MediaPlayer player = new MediaPlayer();

        player.pressPlay(); // Play
        player.pressPlay(); // Pause
    }
}

Output
Playing the music
Pausing the music


üß© How State Pattern Solves the Problem
*****************************************
‚û§ No if-else on state
‚û§ Behavior is moved into state classes
‚û§ Easy to add new states
‚û§ Clean separation of concerns

üß© Advantages
**************
‚û§ Eliminates complex conditional logic
‚û§ Easy to add new states
‚û§ Improves code readability
‚û§ Encapsulates state-specific behavior
‚û§ Follows SRP & OCP

üß© Disadvantages
******************
‚û§ Increases number of classes
‚û§ State transition logic can be scattered
‚û§ Might be overkill for simple state logic

üß© State vs Strategy 
*********************
‚û§ State Pattern
‚û§ State changes automatically
‚û§ Context controls transitions
‚û§ Used when behavior depends on internal state

‚û§ Strategy Pattern
‚û§ Strategy chosen by client
‚û§ No automatic switching
‚û§ Used for interchangeable algorithms

üß© State vs If-Else
********************
‚û§ If-Else
‚û§ Hard to maintain
‚û§ Breaks OCP
‚û§ Difficult to extend

‚û§ State Pattern
‚û§ Clean & extensible
‚û§ Behavior encapsulated
‚û§ Easy to maintain

üß© Common Interview Questions
********************************
‚û§ What is State Design Pattern?
‚û§ Difference between State and Strategy?
‚û§ Real-world use cases of State pattern?
‚û§ How does State eliminate if-else?
‚û§ What happens when a new state is added?
‚û§ Is State pattern behavioral or structural?

‚û§ Triggers the command
‚û§ Client
‚û§ Creates and assigns commands to invoker

###########################
üß© Command Design Pattern 
###########################
üß© Definition
***************
‚û§ The Command Pattern is a Behavioral Design Pattern that turns a request into a standalone object containing all information about the request.
‚û§ This allows you to parameterize clients with different requests, queue or log them, and support undo/redo operations.

‚û§ In simple words:
Command encapsulates a request as an object.

üß© Intent (Why Command Pattern?)
**********************************
‚û§ To decouple the sender (invoker) from the receiver (actual object performing the action)
‚û§ To treat requests as objects
‚û§ To support undo/redo functionality
‚û§ To queue, log, or schedule operations
‚û§ To remove hard-coded method calls

üß© Real-World Examples
************************
‚û§ TV remote buttons (ON, OFF, Volume Up)
‚û§ Menu items in GUI applications
‚û§ Undo/Redo in editors (Word, VS Code)
‚û§ Job queues
‚û§ Transaction systems
‚û§ Spring Runnable, Callable
‚û§ Servlet request handling
‚û§ Macro commands (execute multiple commands together)

üß© When to Use Command Pattern?
*********************************
‚û§ When you want to decouple UI actions from business logic
‚û§ When you want to support undo/redo
‚û§ When commands need to be queued or logged
‚û§ When operations should be treated uniformly
‚û§ When you want to parameterize objects with operations

üß© Key Characteristics (Must-Know for Interviews)
**************************************************
‚û§ Request is wrapped in a command object
‚û§ Invoker doesn‚Äôt know how the request is executed
‚û§ Receiver performs the actual action
‚û§ Supports undo/redo easily
‚û§ Follows Open/Closed Principle

üß© Structure (UML Essentials)
*******************************
‚û§ Command (Interface / Abstract Class)
‚û§ Declares execution method

‚û§ ConcreteCommand
‚û§ Binds receiver and implements execute/undo

‚û§ Receiver
‚û§ Knows how to perform the operation

‚û§ Invoker
‚û§ Triggers the command

‚û§ Client
‚û§ Creates and assigns commands to invoker

üß© Java Example ‚Äî Remote Control (Classic Example)
****************************************************
1Ô∏è‚É£ Command Interface
----------------------
public interface Command {
    void execute();
}

2Ô∏è‚É£ Receiver
------------
public class Light {
    public void turnOn() {
        System.out.println("Light is ON");
    }
    public void turnOff() {
        System.out.println("Light is OFF");
    }
}

3Ô∏è‚É£ Concrete Commands
-----------------------
public class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.turnOn();
    }
}

public class LightOffCommand implements Command {
    private Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.turnOff();
    }
}

4Ô∏è‚É£ Invoker
------------
public class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}

5Ô∏è‚É£ Client Code
-----------------
public class Client {
    public static void main(String[] args) {
        Light light = new Light();

        Command onCommand = new LightOnCommand(light);
        Command offCommand = new LightOffCommand(light);

        RemoteControl remote = new RemoteControl();

        remote.setCommand(onCommand);
        remote.pressButton();

        remote.setCommand(offCommand);
        remote.pressButton();
    }
}

üß© Output
-----------
Light is ON
Light is OFF

üß© Undo / Redo Support (Interview Favorite)
*********************************************
‚û§ Add an undo() method in Command
‚û§ Store command history in stack

public interface Command {
    void execute();
    void undo();
}

‚û§ Used heavily in editors and transaction systems

üß© Macro Command (Advanced Concept)
*************************************
‚û§ Command that executes multiple commands together
‚û§ Example: ‚ÄúTurn off all lights‚Äù

üß© Advantages
***************
‚û§ Decouples sender and receiver
‚û§ Easy to add new commands
‚û§ Supports undo/redo
‚û§ Supports logging and queuing
‚û§ Clean and extensible design

üß© Disadvantages
******************
‚û§ Increases number of classes
‚û§ Can add complexity for simple use cases
‚û§ Requires careful command management

üß© Command vs Strategy vs Observer (Interview Trap)
*****************************************************
‚û§ Command
‚û§ Encapsulates a request
‚û§ Focus on when and how to execute

‚û§ Strategy
‚û§ Encapsulates algorithms
‚û§ Focus on how something is done

‚û§ Observer
‚û§ Notifies multiple objects on state change

üß© Common Interview Questions
*******************************
‚û§ What is Command Pattern?
‚û§ How does Command support undo/redo?
‚û§ Difference between Command and Strategy?
‚û§ Real-world use cases?
‚û§ What is a Macro Command?
‚û§ How does Command decouple sender and receiver?

##############################
üß© Composite Design Pattern 
##############################
üß© Definition
**************
‚û§ The Composite Pattern is a Structural Design Pattern that lets you treat individual objects and groups of objects uniformly.
‚û§ It composes objects into a tree structure (part‚Äìwhole hierarchy) and allows clients to work with leaf and composite objects in the same way.

üß© Intent (Why Composite Pattern?)
************************************
‚û§ To represent hierarchical structures (tree-like).
‚û§ To allow clients to treat single objects and collections uniformly.
‚û§ To simplify client code by removing special-case handling.
‚û§ To follow Open/Closed Principle when adding new components.

üß© Real-World Examples
************************
‚û§ File system
‚û§ File (Leaf)
‚û§ Folder (Composite)
‚û§ Organization structure
‚û§ Employee ‚Üí Manager ‚Üí Director
‚û§ HTML DOM tree
‚û§ Menu and sub-menu systems
‚û§ Java Swing components (JComponent)
‚û§ XML / JSON tree structures

üß© When to Use Composite Pattern?
***********************************
‚û§ When your problem naturally forms a tree structure.
‚û§ When clients should not care whether they are dealing with a single object or a group.
‚û§ When you want uniform operations on both leaf and composite objects.

üß© Key Characteristics 
************************
‚û§ Uses recursive composition.
‚û§ Leaf and Composite implement the same interface.
‚û§ Client interacts only with the Component interface.
‚û§ Simplifies client logic.
‚û§ Tree structure (part‚Äìwhole hierarchy).

üß© Structure (UML Essentials)
********************************
‚û§ Component (Interface / Abstract Class)
‚û§ Declares common operations

‚û§ Leaf
‚û§ Represents individual objects
‚û§ No children

‚û§ Composite
‚û§ Stores child components
‚û§ Implements child-related operations

‚û§ Client
‚û§ Works with Component interface

üß© Java Example ‚Äî File System
*******************************
1Ô∏è‚É£ Component
--------------
public interface FileSystemComponent {
    void showDetails();
}

2Ô∏è‚É£ Leaf
----------
public class File implements FileSystemComponent {
    private String name;

    public File(String name) {
        this.name = name;
    }

    @Override
    public void showDetails() {
        System.out.println("File: " + name);
    }
}

3Ô∏è‚É£ Composite
--------------
import java.util.ArrayList;
import java.util.List;

public class Folder implements FileSystemComponent {
    private String name;
    private List<FileSystemComponent> children = new ArrayList<>();

    public Folder(String name) {
        this.name = name;
    }

    public void add(FileSystemComponent component) {
        children.add(component);
    }

    public void remove(FileSystemComponent component) {
        children.remove(component);
    }

    @Override
    public void showDetails() {
        System.out.println("Folder: " + name);
        for (FileSystemComponent component : children) {
            component.showDetails();
        }
    }
}

4Ô∏è‚É£ Client Code
----------------
public class Main {
    public static void main(String[] args) {
        File file1 = new File("resume.pdf");
        File file2 = new File("photo.png");

        Folder documents = new Folder("Documents");
        documents.add(file1);
        documents.add(file2);

        Folder root = new Folder("Root");
        root.add(documents);

        root.showDetails();
    }
}

üß© Output
-----------
Folder: Root
Folder: Documents
File: resume.pdf
File: photo.png

üß© Advantages
***************
‚û§ Treats individual and composite objects uniformly
‚û§ Simplifies client code
‚û§ Easy to add new components
‚û§ Natural representation of tree structures
‚û§ Follows Open/Closed Principle

üß© Disadvantages
******************
‚û§ Hard to restrict components (leaf vs composite rules)
‚û§ Can make design overly general
‚û§ Debugging recursive structures can be tricky

üß© Composite vs Decorator 
**************************
‚û§ Composite
‚û§ Focuses on structure (tree)
‚û§ Manages children

‚û§ Decorator
‚û§ Focuses on adding behavior
‚û§ No child management

üß© Composite vs Facade
************************
‚û§ Composite
‚û§ Represents hierarchical relationships

‚û§ Facade
‚û§ Simplifies subsystem access

üß© Real Java Examples
***********************
‚û§ java.awt.Container
‚û§ javax.swing.JComponent
‚û§ DOM API
‚û§ JSON/XML parsers

üß© Common Interview Questions
*******************************
‚û§ What is Composite Pattern?
‚û§ Where is Composite used in real projects?
‚û§ Difference between Composite and Decorator?
‚û§ Can a Composite contain both Leaf and Composite objects? (Yes)
‚û§ What problem does Composite solve?

#############################
üß© Flyweight Design Pattern 
#############################
üß© Definition
****************
‚û§ The Flyweight Pattern is a Structural Design Pattern that reduces memory usage by sharing common (intrinsic) state between multiple objects instead of storing it separately.
‚û§ It is used when large numbers of similar objects are created.

üß© Intent (Why Flyweight?)
****************************
‚û§ To minimize memory consumption
‚û§ To improve performance
‚û§ To share common data across objects
‚û§ To handle massive object creation efficiently

üß© Intrinsic vs Extrinsic State (Very Important)
**************************************************
‚û§ Intrinsic State
‚û§ Shared
‚û§ Stored inside Flyweight
‚û§ Example: character shape, font

‚û§ Extrinsic State
‚û§ Not shared
‚û§ Passed by client
‚û§ Example: position, color

üß© Real-World Examples
*************************
‚û§ Text editors (characters sharing glyph data)
‚û§ Game development (bullets, trees)
‚û§ Caching systems
‚û§ Java String Pool
‚û§ Wrapper classes (Integer.valueOf())

üß© Structure (UML Essentials)
*******************************
‚û§ Flyweight Interface
‚û§ Concrete Flyweight
‚û§ Flyweight Factory
‚û§ Client

üß© Java Example ‚Äî Character Rendering
***************************************
1Ô∏è‚É£ Flyweight Interface
------------------------
public interface Character {
    void display(int x, int y);
}

2Ô∏è‚É£ Concrete Flyweight
-----------------------
public class CharacterFlyweight implements Character {
    private char symbol; // intrinsic

    public CharacterFlyweight(char symbol) {
        this.symbol = symbol;
    }

    public void display(int x, int y) {
        System.out.println(symbol + " at (" + x + "," + y + ")");
    }
}

3Ô∏è‚É£ Flyweight Factory
---------------------
import java.util.*;

public class CharacterFactory {
    private static final Map<Character, Character> cache = new HashMap<>();

    public static Character getCharacter(char c) {
        cache.putIfAbsent(c, new CharacterFlyweight(c));
        return cache.get(c);
    }
}

4Ô∏è‚É£ Client
-----------
Character c1 = CharacterFactory.getCharacter('A');
Character c2 = CharacterFactory.getCharacter('A');
System.out.println(c1 == c2); // true

üß© Advantages
*****************
‚û§ Significant memory reduction
‚û§ Faster performance for large systems
‚û§ Object reuse
‚û§ Efficient caching

üß© Disadvantages
******************
‚û§ Increased complexity
‚û§ Extrinsic state handling required
‚û§ Not suitable for small number of objects

üß© Common Interview Questions
********************************
‚û§ What is Flyweight Pattern?
‚û§ Intrinsic vs Extrinsic state?
‚û§ Where is Flyweight used in Java?
‚û§ Difference between Flyweight and Singleton?
‚û§ Why is String Pool a Flyweight?

############################
üß© Mediator Design Pattern 
############################
üß© Definition
****************
‚û§ The Mediator Pattern is a Behavioral Design Pattern that defines an object (Mediator) to encapsulate how multiple objects interact.
‚û§ Instead of objects communicating directly with each other, they communicate through a mediator.

‚û§ In simple words:
Mediator centralizes communication logic and reduces coupling between objects.

üß© Intent (Why Mediator Pattern?)
**************************************
‚û§ To reduce tight coupling between interacting objects.
‚û§ To avoid complex many-to-many relationships.
‚û§ To centralize communication logic in one place.
‚û§ To make the system easier to maintain and extend.

üß© Problem Without Mediator
*****************************
‚û§ Objects communicate directly with each other.
‚û§ Leads to:
‚û§ Too many dependencies
‚û§ Difficult maintenance
‚û§ Hard-to-change communication logic

Example problem:

User ‚Üí Chat ‚Üí Notification ‚Üí Logging ‚Üí Email ‚Üí SMS

‚û§ Becomes messy very fast ‚ùå

üß© Solution With Mediator
**************************
‚û§ Objects talk only to Mediator.
‚û§ Mediator handles who should talk to whom.
‚û§ Objects become loosely coupled.

üß© Real-World Examples
*************************
‚û§ Air Traffic Control (ATC)
‚û§ Planes don‚Äôt communicate directly
‚û§ ATC (Mediator) controls everything

‚û§ Chat Application
‚û§ Users send messages via chat server

‚û§ UI Dialog Box
‚û§ Buttons, text fields interact through dialog

‚û§ Spring Framework
‚û§ Event handling
‚û§ Microservices communication via API Gateway

üß© Key Characteristics (Must-Know for Interviews)
***************************************************
‚û§ Promotes loose coupling
‚û§ Centralizes communication logic
‚û§ Simplifies object collaboration
‚û§ Colleagues do NOT talk to each other directly
‚û§ Mediator can become complex if overused

üß© Structure (UML Essentials)
*******************************
‚û§ Mediator (Interface / Abstract class)
‚û§ Defines communication methods

‚û§ ConcreteMediator
‚û§ Implements coordination logic

‚û§ Colleague (Abstract class / Interface)
‚û§ Communicates via mediator

‚û§ ConcreteColleagues
‚û§ Actual interacting objects

üß© Java Example ‚Äî Chat Room (Classic Example)
***********************************************
1Ô∏è‚É£ Mediator Interface
-----------------------
public interface ChatMediator {
    void sendMessage(String message, User user);
}

2Ô∏è‚É£ Concrete Mediator
----------------------
import java.util.ArrayList;
import java.util.List;

public class ChatRoom implements ChatMediator {
    private List<User> users = new ArrayList<>();

    public void addUser(User user) {
        users.add(user);
    }

    @Override
    public void sendMessage(String message, User sender) {
        for (User user : users) {
            if (user != sender) {
                user.receive(message);
            }
        }
    }
}

3Ô∏è‚É£ Colleague (User)
---------------------
public abstract class User {
    protected ChatMediator mediator;
    protected String name;

    public User(ChatMediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }

    public abstract void send(String message);
    public abstract void receive(String message);
}

4Ô∏è‚É£ Concrete Colleague
-----------------------
public class ChatUser extends User {

    public ChatUser(ChatMediator mediator, String name) {
        super(mediator, name);
    }

    @Override
    public void send(String message) {
        System.out.println(name + " sends: " + message);
        mediator.sendMessage(message, this);
    }

    @Override
    public void receive(String message) {
        System.out.println(name + " receives: " + message);
    }
}

5Ô∏è‚É£ Client Code
----------------
public class Main {
    public static void main(String[] args) {
        ChatRoom chatRoom = new ChatRoom();

        User u1 = new ChatUser(chatRoom, "A");
        User u2 = new ChatUser(chatRoom, "B");
        User u3 = new ChatUser(chatRoom, "C");

        chatRoom.addUser(u1);
        chatRoom.addUser(u2);
        chatRoom.addUser(u3);

        u1.send("Hello everyone!");
    }
}

üß© Output
-----------
A sends: Hello everyone!
B receives: Hello everyone!
C receives: Hello everyone!

üß© Advantages
***************
‚û§ Reduces coupling between components
‚û§ Centralizes communication logic
‚û§ Easier to maintain and modify
‚û§ Improves code readability
‚û§ Encourages Single Responsibility Principle

üß© Disadvantages
******************
‚û§ Mediator can become a God Object
‚û§ Adds extra layer of abstraction
‚û§ Hard to maintain if mediator becomes too complex

üß© Mediator vs Observer 
*************************
‚û§ Mediator
‚û§ Central controller
‚û§ Objects communicate via mediator

‚û§ Observer
‚û§ One-to-many dependency
‚û§ Observers listen for state changes

üß© Mediator vs Facade
***********************
‚û§ Mediator
‚û§ Controls interaction between peers

‚û§ Facade
‚û§ Simplifies access to subsystem

üß© Common Interview Questions
*******************************
‚û§ What is Mediator Pattern?
‚û§ How does Mediator reduce coupling?
‚û§ Real-world use case of Mediator?
‚û§ Difference between Mediator and Observer?
‚û§ Can Mediator become a God Object?
‚û§ Where is Mediator used in real frameworks?

###############################
üß© Interpreter Design Pattern 
###############################
üß© Definition
***************
‚û§ The Interpreter Pattern is a Behavioral Design Pattern used to define a grammar for a language and provide an interpreter to interpret sentences of that language.
‚û§ It represents grammar rules as classes and uses them to interpret expressions.

‚û§ In simple words:
It converts expressions (rules/grammar) into executable logic.

üß© Intent (Why Interpreter Pattern?)
***************************************
‚û§ To interpret sentences in a simple language.
‚û§ To define grammar rules using classes.
‚û§ To evaluate expressions dynamically.
‚û§ To avoid hardcoding parsing logic.

üß© When to Use Interpreter Pattern?
*************************************
‚û§ When grammar is simple and small
‚û§ When expressions need to be evaluated repeatedly
‚û§ When language rules can be represented as a class hierarchy
‚û§ When performance is not a critical concern

‚ö†Ô∏è Not suitable for complex grammars (use parser generators instead)

üß© Real-World Examples
************************
‚û§ SQL query parsing
‚û§ Regular expression engines
‚û§ Mathematical expression evaluators
‚û§ Rule engines
‚û§ Boolean expression evaluation
‚û§ Spring Expression Language (SpEL ‚Äì conceptually similar)

üß© Key Participants (Must-Know for Interviews)
************************************************
‚û§ AbstractExpression
‚û§ Declares interpret method

‚û§ TerminalExpression
‚û§ Implements grammar for terminal symbols

‚û§ NonTerminalExpression
‚û§ Implements grammar for non-terminal symbols

‚û§ Context
‚û§ Contains information used during interpretation

‚û§ Client
‚û§ Builds expression tree and triggers interpretation

üß© Structure (UML Overview)
*****************************
‚û§ Expression (interface / abstract class)
‚û§ TerminalExpression
‚û§ NonTerminalExpression
‚û§ Context
‚û§ Client

üß© Java Example ‚Äî Boolean Expression Interpreter
**************************************************
1Ô∏è‚É£ Expression Interface
--------------------------
public interface Expression {
    boolean interpret(String context);
}

2Ô∏è‚É£ Terminal Expression
------------------------
public class TerminalExpression implements Expression {
    private String data;

    public TerminalExpression(String data) {
        this.data = data;
    }

    @Override
    public boolean interpret(String context) {
        return context.contains(data);
    }
}

3Ô∏è‚É£ Non-Terminal Expressions
-----------------------------
public class OrExpression implements Expression {
    private Expression expr1;
    private Expression expr2;

    public OrExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    @Override
    public boolean interpret(String context) {
        return expr1.interpret(context) || expr2.interpret(context);
    }
}

public class AndExpression implements Expression {
    private Expression expr1;
    private Expression expr2;

    public AndExpression(Expression expr1, Expression expr2) {
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    @Override
    public boolean interpret(String context) {
        return expr1.interpret(context) && expr2.interpret(context);
    }
}

4Ô∏è‚É£ Client Code
---------------
public class InterpreterDemo {
    public static void main(String[] args) {

        Expression java = new TerminalExpression("Java");
        Expression spring = new TerminalExpression("Spring");

        Expression javaOrSpring = new OrExpression(java, spring);
        Expression javaAndSpring = new AndExpression(java, spring);

        System.out.println(javaOrSpring.interpret("I love Java"));
        System.out.println(javaAndSpring.interpret("Java with Spring"));
    }
}

Output
true
true

üß© Advantages
****************
‚û§ Easy to change or extend grammar
‚û§ Grammar rules are clearly represented as classes
‚û§ Easy to add new expressions
‚û§ Clean separation of grammar and evaluation logic

üß© Disadvantages
******************
‚û§ Class explosion if grammar grows large
‚û§ Hard to maintain complex grammars
‚û§ Performance issues for large expression trees
‚û§ Not suitable for complex languages

üß© Interpreter vs Visitor 
***************************
‚û§ Interpreter
‚û§ Focuses on grammar and evaluation
‚û§ Suitable for simple languages

‚û§ Visitor
‚û§ Focuses on operations on object structures
‚û§ Better for complex object hierarchies

üß© Interpreter vs Strategy
***************************
‚û§ Interpreter ‚Üí Evaluates language grammar
‚û§ Strategy ‚Üí Switches algorithms dynamically

üß© Common Interview Questions
*******************************
‚û§ What is Interpreter Design Pattern?
‚û§ When should Interpreter be avoided?
‚û§ Real-world examples of Interpreter?
‚û§ Difference between Terminal and Non-Terminal expression?
‚û§ Interpreter vs Visitor?
‚û§ Is Interpreter a behavioral pattern? (Yes)

######################
üß© SOLID Principles 
######################
SOLID is a set of 5 object-oriented design principles that help in writing clean, maintainable, scalable, and flexible code.
Proposed by Robert C. Martin (Uncle Bob).

üß© What does SOLID stand for?
*******************************
‚û§ S ‚Üí Single Responsibility Principle (SRP)
‚û§ O ‚Üí Open/Closed Principle (OCP)
‚û§ L ‚Üí Liskov Substitution Principle (LSP)
‚û§ I ‚Üí Interface Segregation Principle (ISP)
‚û§ D ‚Üí Dependency Inversion Principle (DIP)

üß© 1. Single Responsibility Principle (SRP)
*********************************************
‚û§ Definition
===============
‚û§ A class should have only one reason to change.
‚û§ A class should do only one job.

‚ùå Bad Design (Violates SRP)
------------------------------
class Invoice {
    void calculateTotal() {}
    void printInvoice() {}
    void saveToDB() {}
}

‚û§ Problems:
‚û§ Business logic + Printing + DB logic in one class
‚û§ Too many responsibilities
‚û§ Hard to maintain and test

‚úÖ Good Design (Follows SRP)
------------------------------
class Invoice {
    void calculateTotal() {}
}

class InvoicePrinter {
    void printInvoice() {}
}

class InvoiceRepository {
    void saveToDB() {}
}

üéØ Benefits
*************
‚û§ Easy to maintain
‚û§ Easy to test
‚û§ Less coupling
‚û§ High cohesion

üß† Interview Tip
*****************
‚û§ SRP is about reasons to change, not number of methods.

üß© 2. Open/Closed Principle (OCP)
**********************************
‚û§ Definition
===============
‚û§ Software entities should be open for extension but closed for modification.

‚ùå Bad Design
--------------
class DiscountCalculator {
    double calculate(String type) {
        if(type.equals("DIWALI")) return 20;
        if(type.equals("NEWYEAR")) return 30;
        return 0;
    }
}

‚û§ Every new discount ‚Üí modify class
‚û§ Violates OCP

‚úÖ Good Design
-----------------
interface Discount {
    double calculate();
}

class DiwaliDiscount implements Discount {
    public double calculate() { return 20; }
}

class NewYearDiscount implements Discount {
    public double calculate() { return 30; }
}

üéØ Benefits
*************
‚û§ Easy to add new features
‚û§ No risk of breaking existing code
‚û§ Highly scalable design

üß† Interview Tip
*****************
‚û§ OCP is achieved using abstraction, inheritance, polymorphism.

üß© 3. Liskov Substitution Principle (LSP)
*******************************************
‚û§ Definition
===============
‚û§ Objects of a superclass should be replaceable with objects of its subclass without breaking the program.

‚ùå Bad Design
---------------
class Bird {
    void fly() {}
}

class Ostrich extends Bird {
    void fly() {
        throw new UnsupportedOperationException();
    }
}

‚û§ Ostrich cannot fly
‚û§ Breaks LSP

‚úÖ Good Design
----------------
interface Bird {}

interface FlyingBird extends Bird {
    void fly();
}

class Sparrow implements FlyingBird {
    public void fly() {}
}

class Ostrich implements Bird {}

üéØ Benefits
**************
‚û§ Correct use of inheritance
‚û§ Prevents unexpected behavior
‚û§ Improves reliability

üß† Interview Tip
*****************
‚û§ If subclass changes expected behavior ‚Üí LSP violation.

üß© 4. Interface Segregation Principle (ISP)
*********************************************
‚û§ Definition
==============
‚û§ Clients should not be forced to depend on interfaces they do not use.
‚û§ Prefer multiple small interfaces over one big interface.

‚ùå Bad Design
---------------
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() {}
    public void eat() {} // unnecessary
}

‚úÖ Good Design
----------------
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Human implements Workable, Eatable {}
class Robot implements Workable {}

üéØ Benefits
*************
‚û§ Cleaner interfaces
‚û§ Loose coupling
‚û§ Better readability
‚û§ No unused methods

üß† Interview Tip
*******************
‚û§ ISP avoids fat interfaces.

üß© 5. Dependency Inversion Principle (DIP)
*******************************************
‚û§ Definition
===============
‚û§ High-level modules should not depend on low-level modules.
‚û§ Both should depend on abstractions.

‚ùå Bad Design
--------------
class MySQLDatabase {
    void connect() {}
}

class UserService {
    MySQLDatabase db = new MySQLDatabase();
}

‚û§ Tight coupling
‚û§ Hard to change DB

‚úÖ Good Design
-----------------
interface Database {
    void connect();
}

class MySQLDatabase implements Database {
    public void connect() {}
}

class UserService {
    private Database db;
    UserService(Database db) {
        this.db = db;
    }
}

üéØ Benefits
**************
‚û§ Loose coupling
‚û§ Easy to switch implementations
‚û§ Better testability (mocking)

üß† Interview Tip
******************
‚û§ Spring Framework heavily uses DIP via Dependency Injection.

üß© SOLID Principles ‚Äî Quick Revision Table
********************************************
##################################################################
| Principle | Focus          | Goal                              |
| --------- | -------------- | --------------------------------- |
| SRP       | Responsibility | One reason to change              |
| OCP       | Extension      | Add behavior without modification |
| LSP       | Inheritance    | Substitutability                  |
| ISP       | Interfaces     | No unused methods                 |
| DIP       | Dependency     | Depend on abstractions            |
##################################################################

üß© SOLID + Design Patterns (Important Link)
***************************
‚û§ SRP ‚Üí Facade, Command
‚û§ OCP ‚Üí Strategy, Factory, Decorator
‚û§ LSP ‚Üí Proper inheritance usage
‚û§ ISP ‚Üí Adapter, Proxy
‚û§ DIP ‚Üí Spring, Dependency Injection, Factory

üß© Common Interview Questions
*******************************
‚û§ What is SOLID principle?
‚û§ Explain SRP with example
‚û§ How does OCP help in real projects?
‚û§ LSP violation example
‚û§ Difference between ISP and SRP
‚û§ How Spring implements DIP?
‚û§ Which SOLID principle is most important? (All)

##############################
üß© Service Discovery Pattern 
##############################
üß© What is Service Discovery Pattern?
***************************************
‚û§ Service Discovery is a microservices design pattern that helps services find and communicate with each other dynamically without hardcoding IP addresses or ports.
‚û§ It solves the problem of dynamic service locations in distributed systems.

üß© Why Do We Need Service Discovery?
**************************************
‚û§ In microservices:
‚û§ Services are deployed independently
‚û§ Instances scale up/down dynamically
‚û§ IP addresses & ports change frequently

‚û§ Hardcoding service URLs leads to:
‚û§ Tight coupling
‚û§ Poor scalability
‚û§ High maintenance

üëâ Service Discovery provides a dynamic lookup mechanism.

üß© Core Idea (Simple Explanation)
**********************************
‚û§ Services register themselves with a central registry
‚û§ Clients query the registry to find service locations
‚û§ Registry returns available instances
‚û§ Client communicates with the chosen instance

üß© Key Components
*******************
‚û§ Service Provider
‚û§ A microservice that offers functionality
‚û§ Registers itself with the registry

‚û§ Service Consumer
‚û§ A microservice that calls another service

‚û§ Service Registry
‚û§ Central directory of all services
‚û§ Maintains metadata (IP, port, health)

üß© Types of Service Discovery
*******************************
üî∑ 1Ô∏è‚É£ Client-Side Service Discovery
======================================
‚û§ Client queries the service registry directly
‚û§ Client performs load balancing

Flow:
‚û§ Client ‚Üí Service Registry ‚Üí Service Instance

üìå Example Tools
‚û§ Netflix Eureka
‚û§ Ribbon (client-side LB)

Pros:
‚û§ Simple architecture
‚û§ No extra network hop

Cons:
‚û§ Client must implement discovery logic
‚û§ Tightly coupled to registry

üî∑ 2Ô∏è‚É£ Server-Side Service Discovery
======================================
‚û§ Client sends request to a load balancer
‚û§ Load balancer queries registry and forwards request

Flow:
‚û§ Client ‚Üí Load Balancer ‚Üí Service Registry ‚Üí Service Instance

üìå Example Tools
‚û§ AWS ALB / ELB
‚û§ Kubernetes Service
‚û§ NGINX

Pros:
‚û§ Client is simple
‚û§ Centralized load balancing

Cons:
‚û§ Extra infrastructure
‚û§ Slight latency due to extra hop

üß© Service Registration Methods
********************************
‚û§ Self-Registration
‚û§ Service registers itself on startup
‚û§ Deregisters on shutdown

‚û§ Third-Party Registration
‚û§ External agent handles registration
‚û§ Example: Kubernetes

üß© Popular Service Discovery Tools
************************************
‚û§ Netflix Eureka
‚û§ Consul
‚û§ Apache Zookeeper
‚û§ Kubernetes DNS / Services
‚û§ AWS Cloud Map

üß© Service Discovery in Spring Boot (Very Important)
*****************************************************
‚û§ Spring Cloud Netflix Eureka is commonly used

Server:
‚û§ @EnableEurekaServer

Client:
‚û§ @EnableEurekaClient

‚û§ Services register automatically on startup
‚û§ Uses heartbeat mechanism

üß© Benefits
**************
‚û§ No hardcoded service URLs
‚û§ Supports auto-scaling
‚û§ Improves fault tolerance
‚û§ Enables dynamic load balancing
‚û§ Better maintainability

üß© Challenges
****************
‚û§ Registry becomes critical component
‚û§ Needs high availability
‚û§ Network latency
‚û§ Security concerns (service spoofing)

üß© Service Discovery vs API Gateway (Interview Favorite)
*********************************************************
‚û§ Service Discovery
‚û§ Finds service instances
‚û§ Internal communication

‚û§ API Gateway
‚û§ Entry point for clients
‚û§ Handles routing, auth, rate limiting

üëâ Both are often used together

üß© Real-World Example
***********************
‚û§ E-commerce App
‚û§ Order Service
‚û§ Payment Service
‚û§ Inventory Service

‚û§ All services register with Eureka
‚û§ Order Service discovers Payment Service dynamically

üß© Common Interview Questions
*******************************
‚û§ What problem does Service Discovery solve?
‚û§ Difference between client-side and server-side discovery?
‚û§ How does Eureka work internally?
‚û§ What happens if the service registry goes down?
‚û§ How does Kubernetes handle service discovery?
‚û§ Difference between Service Discovery and DNS?

üß© One-Line Summary (For Interviews)
***************************************
‚û§ Service Discovery Pattern enables microservices to dynamically find and communicate with each other without hardcoding network locations.

################################
üß© Database-per-Service Pattern 
#################################
üß© Definition
***************
‚û§ Database-per-Service is a microservices data management pattern where each microservice owns its own database.
‚û§ No other service is allowed to directly access that database ‚Äî interaction happens only via APIs or events.

üß© Intent (Why Database-per-Service?)
****************************************
‚û§ To achieve loose coupling between microservices
‚û§ To allow independent development, deployment, and scaling
‚û§ To avoid shared database bottlenecks
‚û§ To enable service autonomy and team ownership

üß© Core Rule (Very Important for Interviews)
**********************************************
‚û§ One service ‚Üí One database ‚Üí One owner
‚û§ Other services must NOT query that database directly
‚û§ Communication must happen via:
‚û§ REST APIs
‚û§ gRPC
‚û§ Events (Kafka / RabbitMQ)

üß© Why NOT a Shared Database? (Problem Statement)
***************************************************
‚û§ Tight coupling between services
‚û§ Schema changes affect multiple services
‚û§ Hard to deploy independently
‚û§ Difficult to scale services separately
‚û§ Violates microservice autonomy

üìå Shared DB = Distributed Monolith

üß© Architecture Overview
****************************
‚û§ Order Service ‚Üí Order DB
‚û§ Payment Service ‚Üí Payment DB
‚û§ User Service ‚Üí User DB

‚û§ Communication:
‚û§ Order ‚Üí Payment (API/Event)
‚û§ Order ‚Üí User (API/Event)

üß© Polyglot Persistence (Key Advantage)
****************************************
‚û§ Each service can choose the best database for its needs

Examples:
‚û§ User Service ‚Üí PostgreSQL
‚û§ Product Service ‚Üí MongoDB
‚û§ Search Service ‚Üí Elasticsearch
‚û§ Cache Service ‚Üí Redis

üìå Very common interview keyword

üß© How Services Share Data (Without Sharing DB)
*************************************************
1Ô∏è‚É£ API Composition
====================
‚û§ Service A calls Service B‚Äôs API to fetch required data
‚û§ Simple but increases latency

2Ô∏è‚É£ Event-Driven Communication (Preferred)
===========================================
‚û§ Service publishes events
‚û§ Other services consume and store required data locally
‚û§ Leads to eventual consistency

üß© Consistency Model
***********************
‚û§ Strong consistency ‚ùå (not possible across DBs)
‚û§ Eventual consistency ‚úÖ

üìå Microservices trade consistency for availability and scalability

üß© Handling Transactions (Big Interview Topic)
**************************************************
‚û§ 2-Phase Commit (2PC) ‚ùå
‚û§ Not recommended (tight coupling, poor scalability)

‚û§ Saga Pattern ‚úÖ
‚û§ Sequence of local transactions
‚û§ Each service commits its DB
‚û§ Compensating actions on failure

üìå Database-per-service + Saga = Standard microservices approach

üß© Advantages
****************
‚û§ Loose coupling
‚û§ Independent scaling
‚û§ Independent deployments
‚û§ Service autonomy
‚û§ Enables polyglot persistence
‚û§ Better fault isolation

üß© Disadvantages
*******************
‚û§ Complex data consistency
‚û§ Difficult cross-service queries
‚û§ Data duplication
‚û§ Requires distributed transaction handling
‚û§ Operational complexity

üß© Common Anti-Patterns (Avoid These!)
****************************************
‚û§ One DB with multiple schemas
‚û§ One DB user accessing all tables
‚û§ Services running joins across databases
‚û§ Direct DB access from another service

üìå These break microservices principles

üß© Real-World Usage
*********************
‚û§ Netflix microservices
‚û§ Amazon retail services
‚û§ Uber backend architecture
‚û§ Spring Boot + Microservices
‚û§ Kubernetes-based systems

üß© Database-per-Service vs Shared Database
*********************************************
################################################################
| Feature             | Shared Database | Database-per-Service |
| ------------------- | --------------- | -------------------- |
| Coupling            | High ‚ùå         | Low ‚úÖ              |
| Scalability         | Limited ‚ùå      | High ‚úÖ             |
| Deployment          | Difficult ‚ùå    | Independent ‚úÖ      |
| Consistency         | Strong          | Eventual             |
| Microservices Ready | ‚ùå              | ‚úÖ                  |
################################################################

üß© Interview Questions (Very Important)
*****************************************
‚û§ What is Database-per-Service pattern?
‚û§ Why is shared DB bad for microservices?
‚û§ How do services communicate without DB sharing?
‚û§ How do you handle transactions?
‚û§ What is polyglot persistence?
‚û§ How is consistency maintained?
‚û§ Can two services use the same DB engine? (Yes, but not the same schema)

üß© Key One-Line Summary (Interview Gold)
******************************************
‚û§ Database-per-Service ensures service autonomy by preventing data sharing at the database level and enforcing communication via APIs or events.

#########################
üß© API Gateway Pattern 
########################
üß© What is API Gateway?
*************************
‚û§ API Gateway is a single entry point for all client requests in a microservices architecture.
‚û§ Clients do not directly call microservices; instead, they call the API Gateway, which routes requests to appropriate services.

‚û§ Think of it as a reverse proxy + traffic manager + security guard for microservices.

üß© Why Do We Need API Gateway?
********************************
‚û§ In microservices, there are many services
‚û§ Direct client-to-service communication causes:
‚û§ Tight coupling
‚û§ Too many endpoints exposed
‚û§ Security risks
‚û§ Network overhead

‚û§ API Gateway solves these problems by acting as a centralized layer.

üß© Responsibilities of API Gateway
************************************
‚û§ Request Routing
‚û§ Routes incoming requests to correct microservice

‚û§ Authentication & Authorization
‚û§ JWT validation
‚û§ OAuth / API keys

‚û§ Load Balancing
‚û§ Distributes traffic among service instances

‚û§ Rate Limiting
‚û§ Prevents abuse / DDoS attacks

‚û§ Response Aggregation
‚û§ Combines responses from multiple services into one response

‚û§ Protocol Translation
‚û§ HTTP ‚Üî gRPC
‚û§ REST ‚Üî WebSocket

‚û§ Logging & Monitoring
‚û§ Centralized logging
‚û§ Metrics & tracing

üß© API Gateway Architecture
*****************************
Client
   |
   v
API Gateway
   |
   +--> User Service
   +--> Order Service
   +--> Payment Service

‚û§ Client sees only one endpoint
‚û§ Internal microservices remain hidden

üß© Example Without API Gateway (Problem)
******************************************
‚û§ Client calls:
‚û§ /user-service/users
‚û§ /order-service/orders
‚û§ /payment-service/payments

‚ùå Problems:
‚û§ Client must know all services
‚û§ Security logic duplicated
‚û§ Tight coupling

üß© Example With API Gateway (Solution)
*****************************************
‚û§ Client calls:

/api/users
/api/orders
/api/payments

‚û§ API Gateway internally routes requests

‚úÖ Benefits:
***************
‚û§ Simplified client
‚û§ Centralized security
‚û§ Better maintainability

üß© Types of API Gateway
***************************
1Ô∏è‚É£ Single API Gateway
=======================
‚û§ One gateway for all clients
‚û§ Simple but can become bottleneck

2Ô∏è‚É£ Backend for Frontend (BFF)
==============================
‚û§ Separate gateways for:
‚û§ Web
‚û§ Mobile
‚û§ Admin

‚û§ Each gateway optimized for its client

üß© Popular API Gateway Tools
******************************
‚û§ Netflix Zuul
‚û§ Spring Cloud Gateway
‚û§ Kong
‚û§ NGINX
‚û§ AWS API Gateway
‚û§ Apigee

üß© API Gateway vs Service Discovery
*************************************
‚û§ API Gateway
‚û§ Entry point for clients
‚û§ Handles cross-cutting concerns

‚û§ Service Discovery
‚û§ Helps services find each other
‚û§ Used internally by gateway & services

üëâ They work together, not replacements

üß© Advantages
***************
‚û§ Centralized security
‚û§ Simplified client communication
‚û§ Hides internal architecture
‚û§ Easier monitoring & logging
‚û§ Reduces client-side complexity

üß© Disadvantages
******************
‚û§ Single point of failure (if not replicated)
‚û§ Added latency
‚û§ Increased operational complexity
‚û§ Gateway can become too heavy if overloaded with logic

üß© Best Practices (Interview Gold ‚≠ê)
***************************************
‚û§ Keep gateway thin (no business logic)
‚û§ Use rate limiting & circuit breakers
‚û§ Deploy multiple instances for fault tolerance
‚û§ Prefer BFF pattern for large systems
‚û§ Use caching where possible

üß© Real-World Usage
********************
‚û§ Netflix microservices
‚û§ Amazon backend services
‚û§ Spring Boot microservices projects
‚û§ Kubernetes-based architectures

üß© Common Interview Questions
*********************************
‚û§ What problem does API Gateway solve?
‚û§ API Gateway vs Load Balancer?
‚û§ What is BFF pattern?
‚û§ Can API Gateway replace service discovery?
‚û§ What should NOT be done in API Gateway?
‚û§ How do you secure microservices using API Gateway?

#########################
üß© Distributed Tracing
##########################
üß© What is Distributed Tracing?
*********************************
‚û§ Distributed Tracing is a technique used in microservices architectures to track and monitor a single request as it travels across multiple services.
‚û§ It helps answer questions like:
‚û§ Which service is slow?
‚û§ Where did the request fail?
‚û§ How much time is spent in each service?

üß© Why Distributed Tracing is Needed?
****************************************
‚û§ In monolithic apps ‚Üí one service ‚Üí easy debugging
‚û§ In microservices ‚Üí request passes through many services
‚û§ Logs alone are not enough
‚û§ Metrics show what is slow, tracing shows where & why

üëâ Without tracing ‚Üí debugging becomes very difficult

üß© Core Concepts (Very Important for Interviews)
**************************************************
üîπ 1Ô∏è‚É£ Trace
=============
‚û§ A Trace represents the entire lifecycle of a request
‚û§ Identified by a Trace ID
‚û§ Example:

User Request ‚Üí API Gateway ‚Üí Order Service ‚Üí Payment Service ‚Üí Inventory Service

üîπ 2Ô∏è‚É£ Span
==============
‚û§ A Span represents one operation within a trace
‚û§ Each service creates its own span
‚û§ Has:
‚û§ Span ID
‚û§ Parent Span ID
‚û§ Start time & End time

üîπ 3Ô∏è‚É£ Trace ID
=================
‚û§ Unique identifier for a request
‚û§ Same Trace ID flows across all services

üîπ 4Ô∏è‚É£ Context Propagation
============================
‚û§ Trace ID & Span ID are passed between services
‚û§ Usually via HTTP headers

Example headers:

X-B3-TraceId
X-B3-SpanId
traceparent (W3C standard)

üß© How Distributed Tracing Works (Flow)
******************************************
‚û§ Client sends request
‚û§ API Gateway creates Trace ID
‚û§ Trace ID passed to Service A
‚û§ Service A creates Span A
‚û§ Service A calls Service B ‚Üí passes Trace ID
‚û§ Service B creates Span B
‚û§ All spans are sent to a Tracing System
‚û§ UI shows complete request flow visually

üß© Architecture Components
****************************
‚û§ Instrumentation
‚û§ Code or agents that generate traces
‚û§ Manual or automatic (OpenTelemetry)

‚û§ Collector
‚û§ Receives trace data
‚û§ Aggregates & processes spans

‚û§ Storage
‚û§ Stores traces (ElasticSearch, Cassandra, etc.)

‚û§ Visualization UI
‚û§ Shows request flow, latency, errors

üß© Popular Distributed Tracing Tools
*************************************
‚û§ Jaeger (CNCF, Uber)
‚û§ Zipkin
‚û§ OpenTelemetry (Industry standard)
‚û§ AWS X-Ray
‚û§ Datadog APM
‚û§ New Relic

üß© OpenTelemetry (Important Modern Concept)
*********************************************
‚û§ Vendor-neutral standard
‚û§ Supports traces, metrics, logs
‚û§ Works with Spring Boot, Java, Go, Python, etc.
‚û§ Can export data to Jaeger, Zipkin, Datadog

üëâ Interview Tip: ‚ÄúOpenTelemetry is becoming the standard for observability‚Äù

üß© Example (Spring Boot Microservices)
****************************************
‚û§ API Gateway ‚Üí Order Service ‚Üí Payment Service
‚û§ Each service automatically creates spans
‚û§ Trace visualized like a timeline

Trace ID: abc123
|-- API Gateway (5ms)
|-- Order Service (20ms)
    |-- Payment Service (50ms) ‚ùå slow


üß© Benefits of Distributed Tracing
***********************************
‚û§ End-to-end request visibility
‚û§ Faster debugging
‚û§ Identify latency bottlenecks
‚û§ Root cause analysis
‚û§ Improves system reliability
‚û§ Essential for microservices

üß© Distributed Tracing vs Logging vs Metrics (Interview Favorite)
*******************************************************************
###########################################################################
| Feature     | Logging        | Metrics            | Distributed Tracing |
| ----------- | -------------- | ------------------ | ------------------- |
| Scope       | Single service | Aggregated         | End-to-end          |
| Use case    | Debug details  | Performance trends | Request flow        |
| Correlation | Hard           | Medium             | Easy                |
###########################################################################

üëâ Best practice: Use all three together (Observability)

üß© Challenges
****************
‚û§ Performance overhead
‚û§ Large data volume
‚û§ Sampling needed
‚û§ Proper context propagation is critical
‚û§ Complex setup initially

üß© Sampling in Distributed Tracing
************************************
‚û§ Record only a % of requests
‚û§ Types:
‚û§ Head-based sampling
‚û§ Tail-based sampling

üëâ Reduces cost and overhead

üß© Real-World Use Cases
**************************
‚û§ Debugging slow API calls
‚û§ Monitoring microservices latency
‚û§ SLA monitoring
‚û§ Production issue root cause analysis
‚û§ Cloud-native applications

üß© Common Interview Questions
********************************
‚û§ What is distributed tracing?
‚û§ Difference between tracing, logging, and metrics?
‚û§ What is a trace vs span?
‚û§ How is Trace ID propagated?
‚û§ Tools used for distributed tracing?
‚û§ What is OpenTelemetry?
‚û§ Why sampling is needed?

üß© One-Line Summary (Interview Ready)
****************************************
‚û§ Distributed tracing tracks a request across multiple microservices using trace IDs and spans to identify latency and failures end-to-end.

############################
üß© Circuit Breaker Pattern 
############################
üß© Definition
***************   
‚û§ The Circuit Breaker Pattern is a resilience pattern used in distributed systems / microservices to prevent cascading failures.
‚û§ It works like an electrical circuit breaker:
‚û§ If failures exceed a threshold ‚Üí circuit opens
‚û§ Requests are blocked immediately
‚û§ System gets time to recover

üß© Why Circuit Breaker is Needed? (Problem Statement)
********************************************************
‚û§ In microservices, services depend on other services
‚û§ If Service B is down or slow and Service A keeps calling it:
‚û§ Threads get blocked
‚û§ Latency increases
‚û§ System resources exhaust
‚û§ Cascading failure happens

üëâ Circuit Breaker fails fast instead of waiting and breaking the whole system.

üß© Real-World Analogy
**********************
‚û§ Electrical circuit breaker trips when overload occurs
‚û§ Stops current flow to prevent damage
‚û§ After some time, it can be reset

‚û§ Same logic in software systems

üß© Key Goals of Circuit Breaker
********************************
‚û§ Prevent cascading failures
‚û§ Improve system stability
‚û§ Fail fast and return fallback responses
‚û§ Give failing service time to recover
‚û§ Protect threads and resources

üß© Core States of Circuit Breaker (Very Important)
****************************************************
üî¥ 1) Closed State (Normal Operation)
=======================================
‚û§ All requests are allowed
‚û§ Failures are monitored
‚û§ If failures exceed threshold ‚Üí move to Open

üî¥ 2) Open State (Failure Mode)
=================================
‚û§ Requests are blocked immediately
‚û§ No call is made to downstream service
‚û§ Fallback response is returned
‚û§ After a timeout ‚Üí move to Half-Open

üü° 3) Half-Open State (Testing Mode)
=====================================
‚û§ Limited number of test requests allowed
‚û§ If success ‚Üí circuit closes
‚û§ If failure ‚Üí circuit opens again

üß© State Flow (Interview Diagram in Words)
*******************************************
‚û§ Closed ‚Üí (Failures exceed threshold) ‚Üí Open
‚û§ Open ‚Üí (Timeout elapsed) ‚Üí Half-Open
‚û§ Half-Open ‚Üí (Success) ‚Üí Closed
‚û§ Half-Open ‚Üí (Failure) ‚Üí Open

üß© Important Configuration Parameters
***************************************
‚û§ Failure threshold
‚û§ Number / percentage of failures to open circuit

‚û§ Timeout / Sleep window
‚û§ How long circuit stays open

‚û§ Success threshold
‚û§ Required successes in Half-Open state

‚û§ Request volume threshold
‚û§ Minimum requests before evaluating failures

üß© Fallback Mechanism 
***********************
‚û§ When circuit is OPEN:
‚û§ Return default response
‚û§ Cached data
‚û§ Graceful error message

üëâ Example:
‚û§ ‚ÄúService unavailable, please try later‚Äù

üß© Java / Spring Boot Example (Conceptual)
********************************************
@CircuitBreaker(name = "paymentService", fallbackMethod = "fallbackPayment")
public String makePayment() {
    // Call remote service
    return restTemplate.getForObject(url, String.class);
}

public String fallbackPayment(Exception e) {
    return "Payment service is currently unavailable";
}

‚û§ Common libraries:
‚û§ Resilience4j (Most popular now)
‚û§ Hystrix (Deprecated)

üß© Real-World Use Cases
****************************
‚û§ Payment service failure handling
‚û§ External API calls (third-party APIs)
‚û§ Microservice-to-microservice calls
‚û§ Cloud-native systems
‚û§ Netflix, Amazon, Uber-style architectures

üß© Advantages
***************
‚û§ Prevents cascading failures
‚û§ Improves fault tolerance
‚û§ Fast failure response
‚û§ Better user experience
‚û§ Protects system resources

üß© Disadvantages
*******************
‚û§ Added complexity
‚û§ Requires proper tuning
‚û§ Incorrect configuration may block healthy services
‚û§ Needs monitoring and metrics

üß© Circuit Breaker vs Retry Pattern 
*************************************
‚û§ Retry Pattern
‚û§ Re-attempts failed request
‚û§ Useful for transient failures
‚û§ Can worsen overload if used alone

‚û§ Circuit Breaker
‚û§ Stops requests after repeated failures
‚û§ Prevents overload

üëâ Best Practice:
‚û§ Use Retry + Circuit Breaker together

üß© Circuit Breaker vs Timeout
********************************
‚û§ Timeout
‚û§ Limits waiting time for response

‚û§ Circuit Breaker
‚û§ Decides whether to make the call at all

üß© How Circuit Breaker Helps in Microservices
***********************************************
‚û§ Isolates failures
‚û§ Improves overall system resilience
‚û§ Works well with:
‚û§ API Gateway
‚û§ Service Mesh
‚û§ Load Balancer

üß© Common Interview Questions
*******************************
‚û§ What is Circuit Breaker Pattern?
‚û§ Why is it important in microservices?
‚û§ Explain Closed, Open, Half-Open states
‚û§ Difference between Circuit Breaker and Retry?
‚û§ What is fallback?
‚û§ Which libraries are used in Spring Boot?
‚û§ How does Circuit Breaker prevent cascading failures?

üß© One-Line Summary (Revision Ready)
**************************************
‚û§ Circuit Breaker prevents repeated calls to failing services by failing fast and allowing recovery time.