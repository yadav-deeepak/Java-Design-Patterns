#############################
üß© Singleton Design Pattern 
#############################
‚û§ Definition
***************
The Singleton Pattern ensures that only one object of a class is created during the entire application lifecycle and provides a global point of access to that object.

üß© Why do we need Singleton?
******************************
‚û§ To control access to shared resources such as:
‚û§ Logging
‚û§ Database connection
‚û§ Caches
‚û§ Configuration settings
‚û§ Thread pools

üß© Key Characteristics (Must-Know for Interviews)
***************************************************
‚û§ Only one instance exists.
‚û§ Lazy or Eager creation depending on design.
‚û§ Global access point (getInstance() method).
‚û§ Must be thread-safe in multi-threaded applications.
‚û§ Must prevent cloning, reflection, and serialization from breaking the Singleton property (important interview point).

üß© Types of Singleton Implementations
***************************************
1) Eager Initialization (Simple & Thread-Safe)
===============================================
‚û§ Instance created at class loading time.

public class Singleton {
    private static final Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}

‚û§ Pros: Simple, thread-safe
‚û§ Cons: Instance created even if unused (memory waste)

2) Lazy Initialization (Not Thread-Safe)
===========================================
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

‚û§ Pros: Instance created only when needed
‚û§ Cons: Not thread-safe ‚Üí multiple threads may create multiple instances

3) Thread-Safe Singleton (Synchronized Method)
==============================================
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}

‚û§ Pros: Thread-safe
‚û§ Cons: Slow due to synchronization on every call

4) Double-Checked Locking (Best Performance)
==============================================
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

‚û§ Pros: Fast + thread-safe
‚û§ Cons: Slightly complex
‚û§ volatile is required to prevent instruction reordering

5) Bill Pugh (Static Inner Class) ‚Äì The Best Recommended Approach
==================================================================
public class Singleton {
    private Singleton() {}
    private static class Helper {
        private static final Singleton instance = new Singleton();
    }
    public static Singleton getInstance() {
        return Helper.instance;
    }
}

‚û§ Pros:
‚û§ Lazy-loaded
‚û§ Thread-safe
‚û§ No synchronization overhead
‚û§ Cons: None ‚Äî widely accepted as best practice

6) Enum Singleton (Most Robust)
=================================
public enum Singleton {
    INSTANCE;
}

‚û§ Pros:
‚û§ Prevents serialization issues
‚û§ Prevents reflection attacks
‚û§ Cons:
‚û§ Cannot be lazily loaded
‚û§ Less flexible (cannot extend another class)

üß© How Singleton Protects Against Attacks
*******************************************
‚û§ Reflection attack
‚û§ Private constructor may still be accessed
‚û§ Fix ‚Üí throw exception inside constructor

‚û§ Serialization attack
‚û§ Fix ‚Üí implement readResolve()

‚û§ Cloning attack
‚û§ Fix ‚Üí override clone to throw exception

üß© Real-World Examples
************************
‚û§ Database connection manager (JDBC)
‚û§ Spring beans (by default Singleton scope)
‚û§ Logger frameworks (Log4j, SLF4J)
‚û§ Runtime class in Java (Runtime.getRuntime() is a singleton)

üß© Advantages
****************
‚û§ Controlled access to a single shared resource
‚û§ Saves memory ‚Äî only one instance
‚û§ Avoids inconsistent state
‚û§ Useful for centralized configurations

üß© Disadvantages
*******************
‚û§ Hard to unit test (global state)
‚û§ Can become a God Object
‚û§ Can cause hidden dependencies
‚û§ Encourages tight coupling

üß© Frequently Asked Interview Questions
*****************************************
‚û§ What is a Singleton pattern?
‚û§ Why are Singletons used?
‚û§ Difference between lazy and eager initialization?
‚û§ How do you make a Singleton thread-safe?
‚û§ Why use volatile in double-checked locking?
‚û§ How does Singleton break with serialization/cloning/reflection?
‚û§ Why is Enum Singleton preferred?

############################
üß© Factory Design Pattern
############################
üß© Definition
***************
‚û§ The Factory Pattern (also called Factory Method Pattern) is a Creational Design Pattern that provides a way to create objects without exposing the object creation logic to the client.
‚û§ Instead of calling the constructor directly, the client uses a factory method to create objects.

üß© Intent (Why Factory Method?)
*********************************
‚û§ To define an interface for creating objects but let subclasses decide which class to instantiate.
‚û§ Helps in creating objects when the exact type is determined at runtime.
‚û§ Provides loose coupling by eliminating direct dependency on concrete classes.

üß© Key Characteristics (Must-Know for Interviews)
***************************************************
‚û§ Client uses factory instead of new.
‚û§ Reduces tight coupling between object creation and usage.
‚û§ Helps follow SOLID principles (especially OCP & SRP).
‚û§ Object type is selected based on input/logic.
‚û§ Easy to add new product types without modifying existing code.

üß© When to Use Factory Pattern?
*********************************
‚û§ When you don‚Äôt know the exact object to create until runtime
‚û§ When a class wants its subclasses to specify the objects it creates
‚û§ When object creation logic is complex
‚û§ When you want to centralize object creation
‚û§ When you want to reduce dependency on concrete classes

üß© Real-World Examples
**************************
‚û§ Java Calendar.getInstance()
‚û§ JDBC DriverManager.getConnection()
‚û§ Spring Bean Factory / ApplicationContext
‚û§ NumberFormat.getInstance()
‚û§ Log4j LogManager

üß© Simple Example ‚Äî Without Factory (Problem)
================================================
Car car = new Swift();  // tightly coupled to Swift class

‚û§ Problem: If you want Baleno or Fortuner ‚Üí modify code everywhere.

üß© Using Factory Pattern (Solution)
======================================
Step 1: Create Product Interface
---------------------------------
public interface Car {
    void drive();
}

Step 2: Create Concrete Products
-----------------------------------
public class Swift implements Car {
    public void drive() { System.out.println("Swift driving..."); }
}

public class Baleno implements Car {
    public void drive() { System.out.println("Baleno driving..."); }
}

Step 3: Create Factory Class
-------------------------------
public class CarFactory {

    public static Car getCar(String type) {
        if (type.equalsIgnoreCase("swift")) {
            return new Swift();
        } else if (type.equalsIgnoreCase("baleno")) {
            return new Baleno();
        }
        return null;
    }
}

Step 4: Client Code
--------------------
Car car = CarFactory.getCar("baleno");
car.drive();

‚û§ Client does not know how objects are created ‚Üí loose coupling achieved.

üß© Factory Pattern UML Structure
**********************************
‚û§ Creator (Factory Class)
‚û§ Contains Factory Method (getObject())

‚û§ Product Interface (Common Parent)
‚û§ Car

‚û§ Concrete Products
‚û§ Swift
‚û§ Baleno

‚û§ Client
‚û§ Calls the factory

üß© Advantages
****************
‚û§ Less coupling between client and objects
‚û§ Centralized object creation
‚û§ Code becomes more maintainable
‚û§ Follows Open/Closed Principle
‚û§ Helpful when object creation is complex

üß© Disadvantages
********************
‚û§ More classes (Factory + Product classes)
‚û§ Sometimes adds unnecessary abstraction
‚û§ Switch/if-else can grow if many products are added
‚û§ (But can be fixed using more advanced patterns like Abstract Factory or Factory Method Pattern with inheritance)

üß© Variations of Factory Pattern
***********************************
1) Simple Factory (Not part of GoF, but commonly used)
=========================================================
‚û§ A single factory class with logic to create objects ‚Üí the one we wrote above.

2) Factory Method Pattern (GoF)
================================
‚û§ Lets subclasses decide which class to instantiate
‚û§ Uses inheritance

3) Abstract Factory Pattern
==============================
‚û§ Creates families of related objects
‚û§ Example: UI themes (DarkThemeButton, DarkThemeCheckbox)

üß© Interview Questions (Very Common)
***************************************
‚û§ What is the Factory Method Pattern?
‚û§ How is it different from Abstract Factory?
‚û§ Why not use constructors directly?
‚û§ What problem does Factory solve?
‚û§ Where is Factory used in Java?
‚û§ How does Factory support OCP?
‚û§ Can Factory return different objects based on configuration? (Yes)

############################################
üß© Chain of Responsibility Design Pattern 
############################################
üß© Definition
****************
‚û§ The Chain of Responsibility (CoR) is a Behavioral Design Pattern that allows you to pass a request along a chain of handlers, where each handler decides:
‚û§ whether to process the request, OR
‚û§ pass it to the next handler in the chain.

‚û§ This pattern decouples the sender and receiver and avoids if-else/switch ladders.

üß© Intent (Why Chain of Responsibility?)
******************************************
‚û§ To avoid tightly coupling request sender and receiver.
‚û§ To allow multiple objects a chance to process a request.
‚û§ To build flexible and dynamic chains of handlers.
‚û§ To replace long if-else conditions with clean handler objects.

üß© Real-World Examples
************************
‚û§ Customer support escalation
‚û§ Level 1 ‚Üí Level 2 ‚Üí Level 3
‚û§ ATM withdrawal handler
‚û§ Authentication filters in web security
‚û§ Logging frameworks (INFO ‚Üí DEBUG ‚Üí ERROR)
‚û§ Servlet filters in Java EE
‚û§ Spring Boot Handler Interceptors / Filter Chains
‚û§ Exception handling chain

üß© When to Use CoR Pattern?
******************************
‚û§ When multiple handlers can process a request.
‚û§ When you want to remove large conditional blocks.
‚û§ When handlers should be dynamically arranged.
‚û§ When requests need to be processed or forwarded without knowledge of the receiving handler.

üß© Key Characteristics (Must Know for Interviews)
****************************************************
‚û§ Each handler has a reference to the next handler.
‚û§ Request moves step-by-step through the chain.
‚û§ Handler can:
‚û§ Handle the request
‚û§ OR pass it along
‚û§ OR do both
‚û§ Follows Open/Closed Principle ‚Üí new handlers can be added easily.
‚û§ Decouples sender from receiver.

üß© Structure (UML Essentials)
********************************
‚û§ Handler (abstract class / interface)
‚û§ Defines method to handle request
‚û§ Has reference to next handler

‚û§ Concrete Handlers
‚û§ Implement the actual logic
‚û§ Decide to handle or forward

‚û§ Client
‚û§ Creates and links handlers
‚û§ Sends request to the first handler

üß© Java Example ‚Äî Support Ticket Chain
****************************************
1) Handler Interface
---------------------
public abstract class SupportHandler {
    protected SupportHandler next;

    public void setNextHandler(SupportHandler next) {
        this.next = next;
    }
    public abstract void handleRequest(String issueLevel);
}

2) Concrete Handlers
-----------------------
public class Level1Support extends SupportHandler {
    @Override
    public void handleRequest(String issueLevel) {
        if (issueLevel.equals("LOW")) {
            System.out.println("Level 1 handled the issue");
        } else if (next != null) {
            next.handleRequest(issueLevel);
        }
    }
}

public class Level2Support extends SupportHandler {
    @Override
    public void handleRequest(String issueLevel) {
        if (issueLevel.equals("MEDIUM")) {
            System.out.println("Level 2 handled the issue");
        } else if (next != null) {
            next.handleRequest(issueLevel);
        }
    }
}

public class Level3Support extends SupportHandler {
    @Override
    public void handleRequest(String issueLevel) {
        if (issueLevel.equals("HIGH")) {
            System.out.println("Level 3 handled the issue");
        } else {
            System.out.println("Issue cannot be handled!");
        }
    }
}

3) Client Code
---------------
public class Client {
    public static void main(String[] args) {
        SupportHandler l1 = new Level1Support();
        SupportHandler l2 = new Level2Support();
        SupportHandler l3 = new Level3Support();

        l1.setNextHandler(l2);
        l2.setNextHandler(l3);

        l1.handleRequest("MEDIUM");
    }
}

üß© Output
===========
Level 2 handled the issue

üß© Advantages
***************
‚û§ Eliminates long if-else chains
‚û§ Easy to add new handlers
‚û§ Loose coupling between sender and receiver
‚û§ Follows SRP (each handler has its own logic)
‚û§ Flexible ‚Äî order of handlers can be changed at runtime

üß© Disadvantages
******************
‚û§ Request may go unhandled if chain ends
‚û§ Debugging can be difficult due to indirect flow
‚û§ Performance overhead if chain is long
‚û§ Needs careful ordering of handlers

üß© Common Interview Questions
*******************************
‚û§ What is Chain of Responsibility?
‚û§ How does it reduce coupling?
‚û§ Difference between CoR and Decorator?
‚û§ Can handler both process and forward the request?
‚û§ Real-world examples of CoR?
‚û§ How is it implemented in frameworks like Spring/Servlets?
‚û§ What happens if no handler processes the request?

üß© Difference: Chain of Responsibility vs. Decorator
*******************************************************
‚û§ CoR passes request along a chain ‚Üí only one may handle.
‚û§ Decorator adds additional behavior ‚Üí all decorators execute.

############################
üß© Builder Design Pattern 
############################
üß© Definition
****************
‚û§ The Builder Pattern is a Creational Design Pattern used to construct complex objects step-by-step.
‚û§ Instead of using a large constructor with many parameters, Builder provides a flexible, readable, and controlled way to create objects.

üß© Intent (Why Builder Pattern?)
**********************************
‚û§ To avoid telescoping constructors (constructors with too many parameters).
‚û§ To create objects with optional or mandatory fields clearly.
‚û§ To construct complex objects step-by-step.
‚û§ To build immutable objects safely.

üß© Where Builder is Used in Real Life?
****************************************
‚û§ Creating objects with multiple attributes
‚û§ Building immutable classes (e.g., in Lombok @Builder)
‚û§ Creating HTTP requests (OKHttp, Retrofit)
‚û§ JDBC PreparedStatement building
‚û§ Spring MockMvcBuilders
‚û§ StringBuilder in Java uses a similar but not exact pattern

üß© Problem Without Builder (Telescoping Constructor)
*****************************************************
public class User {
    public User(String name, String email, int age, String address, String phone) {
        // too many params ‚Üí confusing
    }
}

‚û§ Hard to read
‚û§ Hard to maintain
‚û§ Error-prone

üß© Solution: Builder Pattern
********************************
üß± Step-by-Step Object Construction
=====================================
‚û§ Builder allows you to set only the fields you need.
‚û§ Gives chained methods (fluent API).
‚û§ Final object is built using .build().

üß© Complete Java Example
-------------------------
1Ô∏è‚É£ Class to Build
public class User {
    private String name;
    private String email;
    private int age;
    private String address;

    private User(UserBuilder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
        this.address = builder.address;
    }

    public static class UserBuilder {
        private String name;
        private String email;
        private int age;
        private String address;

        public UserBuilder setName(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder setEmail(String email) {
            this.email = email;
            return this;
        }

        public UserBuilder setAge(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder setAddress(String address) {
            this.address = address;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}

2Ô∏è‚É£ Client Code
User user = new User.UserBuilder()
                .setName("Deepak")
                .setEmail("deepak@mail.com")
                .setAge(22)
                .build();


üß© How Builder Improves Code
******************************
‚û§ Readable: Field names appear during object creation
‚û§ Flexible: Optional fields can be ignored
‚û§ Immutable: Object built is final
‚û§ Clean API: No messy constructors
‚û§ Scalable: Easy to add new fields

üß© When to Use Builder Pattern?
*********************************
‚û§ When object has more than 4‚Äì5 parameters
‚û§ When object has optional parameters
‚û§ When object construction should be controlled step-by-step
‚û§ When creating immutable objects
‚û§ When construction logic is complex

üß© Advantages
**************
‚û§ Avoids telescoping constructors
‚û§ Increased readability
‚û§ Helps create immutable objects
‚û§ Cleaner and maintainable code
‚û§ Flexibility in object creation

üß© Disadvantages
*******************
‚û§ More code due to builder class
‚û§ Slightly more memory usage
‚û§ More classes to manage

üß© Builder vs Factory vs Constructor (Interview Favorite)
*************************************************************
‚û§ Constructor:
‚û§ Simple, use when parameters < 3

‚û§ Factory:
‚û§ Decides which object to create

‚û§ Builder:
‚û§ Decides how to construct the object step-by-step

üß© Real-World Examples in Java
********************************
‚û§ StringBuilder, StringBuffer (similar idea)
‚û§ java.lang.ProcessBuilder
‚û§ Lombok @Builder
‚û§ Stream.Builder<T>
‚û§ Calendar.Builder

üß© Common Interview Questions
*******************************
‚û§ What is Builder Pattern?
‚û§ Why is it preferred over telescoping constructors?
‚û§ Difference between Builder and Factory?
‚û§ Can Builder create immutable objects?
‚û§ Describe the real-world examples of Builder.
‚û§ Is Builder a creational or structural pattern?

#############################
üß© Decorator Design Pattern 
#############################
üß© Definition
***************
‚û§ The Decorator Pattern is a Structural Design Pattern used to add new functionalities to an object dynamically, without modifying its original class.
‚û§ Decorators wrap an object and add extra behavior before/after delegating calls to the original object.

üß© Intent (Why Decorator Pattern?)
************************************
‚û§ To extend functionality dynamically at runtime.
‚û§ To avoid subclass explosion (too many subclasses for combinations of features).
‚û§ To add responsibilities to an object without changing existing code (follows OCP).
‚û§ To decorate (wrap) an object with additional features.

üß© Real-World Examples
*************************
‚û§ Java I/O Streams
‚û§ BufferedInputStream wraps FileInputStream
‚û§ DataInputStream, BufferedReader, ZipInputStream
‚û§ Spring Boot Filters (decorating request/response)
‚û§ Adding toppings to pizza (Cheese, Peppers, Olives)
‚û§ Text formatting (bold, italic, underline decorators)
‚û§ Logging wrappers
‚û§ Enhancing service layer with cache/log decorators

üß© Where to Use Decorator Pattern?
************************************
‚û§ When you want to add new behaviors to objects dynamically
‚û§ When subclassing is impractical due to too many combinations
‚û§ When you want to follow Open/Closed Principle
‚û§ When you want to wrap a class with extra logic

üß© Key Characteristics (Must Know for Interviews)
***************************************************
‚û§ Uses composition (wrap object) instead of inheritance.
‚û§ Decorator HAS the same interface as the original component.
‚û§ New behavior can be added before/after delegating calls.
‚û§ Multiple decorators can be stacked.
‚û§ Helps avoid too many subclasses.

üß© Structure (UML Overview)
*****************************
‚û§ Component (Interface)
‚û§ Base interface for both core objects and decorators

‚û§ Concrete Component
‚û§ Actual object you want to decorate

‚û§ Decorator (Abstract class)
‚û§ Implements Component and has a reference to the wrapped Component

‚û§ Concrete Decorators
‚û§ Add new behavior

‚û§ Client
‚û§ Wraps objects with decorators

üß© Java Example ‚Äî Coffee Shop (Classic Decorator Example)
**********************************************************
1Ô∏è‚É£ Component Interface
=========================
public interface Coffee {
    String getDescription();
    double getCost();
}

2Ô∏è‚É£ Concrete Component
======================
public class BasicCoffee implements Coffee {
    public String getDescription() {
        return "Basic Coffee";
    }
    public double getCost() {
        return 50;
    }
}

3Ô∏è‚É£ Decorator (Abstract)
=========================
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

4Ô∏è‚É£ Concrete Decorators
========================
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }
    public double getCost() {
        return coffee.getCost() + 10;
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    public String getDescription() {
        return coffee.getDescription() + ", Sugar";
    }
    public double getCost() {
        return coffee.getCost() + 5;
    }
}

5Ô∏è‚É£ Client Code
===============
public class Main {
    public static void main(String[] args) {
        Coffee coffee = new BasicCoffee();
        coffee = new MilkDecorator(coffee);
        coffee = new SugarDecorator(coffee);

        System.out.println(coffee.getDescription());
        System.out.println("Cost: " + coffee.getCost());
    }
}

Output:
Basic Coffee, Milk, Sugar
Cost: 65.0


üß© Advantages
**************
‚û§ Add functionality at runtime
‚û§ No need to modify existing code
‚û§ Flexible ‚Äî combine decorators in any order
‚û§ Avoids class explosion
‚û§ Follows Open/Closed Principle & Single Responsibility Principle

üß© Disadvantages
******************
‚û§ Many small classes (one per decorator)
‚û§ Debugging can be tricky due to multiple wrapping layers
‚û§ Order of decorators matters
‚û§ Complexity increases if too many decorators are used

üß© Decorator vs Inheritance (Interview Favorite)
**************************************************
‚û§ Inheritance
‚û§ Static behavior
‚û§ Compile-time
‚û§ Adds functionality to entire class

‚û§ Decorator
‚û§ Dynamic behavior
‚û§ Runtime
‚û§ Adds functionality to a single object instance

üß© Decorator vs Chain of Responsibility
******************************************
‚û§ Decorator
‚û§ All decorators execute
‚û§ Used to enhance (add behavior)

‚û§ CoR
‚û§ Only one handler might handle
‚û§ Used to pass request along a chain

üß© Common Interview Questions
******************************
‚û§ What is Decorator Pattern?
‚û§ How is it used in Java I/O?
‚û§ Difference between Decorator and Adapter?
‚û§ Decorator vs Inheritance?
‚û§ Can decorators be nested?
‚û§ Real-life example?

############################
üß© Adapter Design Pattern 
############################
üß© Definition
****************
‚û§ The Adapter Pattern is a Structural Design Pattern that allows two incompatible interfaces to work together.
‚û§ It acts as a bridge between an existing class and a client that expects a different interface.

‚û§ In simple words:
Adapter converts one interface into another interface expected by the client.

üß© Intent (Why Adapter Pattern?)
***********************************
‚û§ To reuse old/existing code with a new system without modifying it.
‚û§ To allow incompatible classes to communicate.
‚û§ To wrap a class with a different interface that the client understands.
‚û§ To follow Open/Closed Principle ‚Äî extend behavior without modifying existing code.

üß© Real-World Examples
***********************
‚û§ Mobile charger adapter ‚Äî Converts 220V to 5V
‚û§ Card reader ‚Äî SD card to USB
‚û§ HDMI-to-VGA converter
‚û§ Java Collections API
‚û§ Arrays.asList() ‚Üí Adapts array to List
‚û§ Spring Web
‚û§ HandlerAdapter allows controllers of different types to work
‚û§ Legacy system integration

üß© When to Use Adapter Pattern?
**********************************
‚û§ When you want to use an existing class but its interface does not match your requirements.
‚û§ When you want to integrate new code with a legacy system.
‚û§ When you need to convert data formats or APIs.
‚û§ When you follow the ‚Äúdon‚Äôt modify existing code‚Äù principle.

üß© Types of Adapter
*********************
‚û§ Object Adapter (Most common)
‚û§ Uses composition
‚û§ Adapter contains the adaptee object

‚û§ Class Adapter
‚û§ Uses inheritance
‚û§ Adapter inherits from Adaptee (not common in Java because Java doesn‚Äôt support multiple inheritance)

üß© Structure (UML Essentials)
*******************************
‚û§ Target Interface ‚Üí What client expects
‚û§ Adaptee ‚Üí Class with incompatible interface
‚û§ Adapter ‚Üí Converts the request to the Adaptee‚Äôs format
‚û§ Client ‚Üí Uses Target interface

üß© Java Example ‚Äî Adapter Pattern (Mobile Charger Analogy)
*************************************************************
1Ô∏è‚É£ Target Interface (What client expects)
===========================================
public interface Charger {
    void chargePhone();
}

2Ô∏è‚É£ Adaptee (Existing incompatible class)
==========================================
public class HomeSocket {
    public void provideElectricity() {
        System.out.println("Providing 240V electricity");
    }
}

3Ô∏è‚É£ Adapter (Converts 240V ‚Üí 5V)
================================
public class ChargerAdapter implements Charger {
    private HomeSocket socket;

    public ChargerAdapter(HomeSocket socket) {
        this.socket = socket;
    }

    @Override
    public void chargePhone() {
        System.out.println("Adapter converting 240V to 5V...");
        socket.provideElectricity();
        System.out.println("Phone is charging safely");
    }
}

4Ô∏è‚É£ Client Code
===============
public class Main {
    public static void main(String[] args) {
        HomeSocket socket = new HomeSocket();
        Charger charger = new ChargerAdapter(socket);
        charger.chargePhone();
    }
}

Output
Adapter converting 240V to 5V...
Providing 240V electricity
Phone is charging safely

üß© Advantages
****************
‚û§ Reuse existing code without modifying it
‚û§ Improves reusability
‚û§ Increases compatibility between old and new code
‚û§ Supports Open/Closed Principle
‚û§ Flexible ‚Äî you can wrap many adapters around the same adaptee

üß© Disadvantages
******************
‚û§ Adds extra layer ‚Äî may increase complexity
‚û§ Too many adapters can make the system hard to understand
‚û§ Not suitable if you can modify the existing class ‚Äî in that case, refactoring is simpler

üß© Adapter vs Decorator vs Proxy
************************************
‚û§ Adapter ‚Üí Converts interface
‚û§ Decorator ‚Üí Adds new behavior
‚û§ Proxy ‚Üí Controls access (security, lazy load, logging)

üß© Real Java Examples
***********************
‚û§ Arrays.asList()
‚û§ InputStreamReader(InputStream)
‚û§ ResourceAdapter in Spring
‚û§ JDBC driver wrappers
‚û§ Log4j to SLF4J bridges

üß© Common Interview Questions
********************************
‚û§ What is Adapter Pattern?
‚û§ Difference between Class Adapter and Object Adapter?
‚û§ How is Adapter used in Java I/O?
‚û§ Adapter vs Decorator vs Proxy?
‚û§ Give real-time example of Adapter in your project.
‚û§ How does Adapter follow OCP?

############################
üß© Iterator Design Pattern
############################
‚û§ Definition
**************
The Iterator pattern provides a standard way to sequentially access elements of a collection without exposing its internal structure.

üß© Key Points
****************
‚û§ Type: Behavioral Pattern
‚û§ Focus: Traverse collections (List, Set, Trees, Custom collections) in a uniform way
‚û§ Goal: Hide the complexity/structure of the underlying data representation

üß© Intent
***********
‚û§ Provide a common interface to iterate over a collection.
‚û§ Allow multiple types of iteration (forward, backward, custom traversal).
‚û§ Decouple traversal logic from collection class.

üß© Where It Is Used in Java
******************************
‚û§ Java‚Äôs Iterator, ListIterator, Iterable interfaces.
‚û§ Enhanced for-loop (for (int x : list)) internally uses Iterator.
‚û§ Collection classes (ArrayList, HashSet, LinkedList) all use it.

üß© Structure (Conceptual)
***************************
‚û§ Iterator
‚ÄÉ‚û§ Provides operations like hasNext() and next()
‚û§ ConcreteIterator
‚ÄÉ‚û§ Implements iteration over a specific collection
‚û§ Aggregate / Iterable
‚ÄÉ‚û§ Creates an iterator
‚û§ ConcreteAggregate
‚ÄÉ‚û§ Returns an iterator for the collection

üß© Simple Java Example
*************************
Collection (Aggregate)
interface Container {
    Iterator getIterator();
}

Iterator Interface
interface Iterator {
    boolean hasNext();
    Object next();
}

Concrete Collection
class NameRepository implements Container {
    private String[] names = { "John", "David", "Sara" };

    @Override
    public Iterator getIterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator {
        int index = 0;

        @Override
        public boolean hasNext() {
            return index < names.length;
        }

        @Override
        public Object next() {
            return hasNext() ? names[index++] : null;
        }
    }
}

Usage
NameRepository repo = new NameRepository();
Iterator it = repo.getIterator();

while (it.hasNext()) {
    System.out.println(it.next());
}

üß© Real-World Examples
************************
‚û§ TV remote channels ‚Äî press next/previous without knowing stored channel list
‚û§ Music playlist ‚Äî iterate songs sequentially
‚û§ Browser history ‚Äî go forward/backward

üß© Advantages
****************
‚û§ Uniform traversal across different collections
‚û§ Encapsulation ‚Äî hides internal structure
‚û§ Multiple iteration algorithms possible
‚û§ Supports parallel or custom iterators

üß© Disadvantages
*******************
‚û§ Extra classes (Iterator, ConcreteIterator) increase complexity
‚û§ Multiple iterators on the same collection may cause concurrency issues

üß© When to Use
***************
‚û§ You want to iterate without exposing internal data structure.
‚û§ You want to support multiple traversal types (reverse, filtered, custom).
‚û§ You want clean separation between collection and traversal logic.

üß© Interview Questions
************************
‚û§ Why do we need Iterator when we have simple loops?
‚û§ Difference between Iterator and ListIterator?
‚û§ Why is Iterator.remove() preferred over modifying during iteration?
‚û§ Fail-fast vs Fail-safe iterator in Java?
‚û§ Internal working of foreach loop in Java?

############################
üß© Observer Design Pattern
############################
‚û§ Definition
**************
The Observer Pattern defines a one-to-many dependency between objects so that when one object (Subject) changes its state, all its dependents (Observers) are notified automatically.

üß† Why Is It Used? (Intent)
*****************************
‚û§ To achieve loose coupling between objects.
‚û§ To ensure automatic updates to subscribers when the data changes.
‚û§ To support event-driven systems.

üîß Where Is It Used? (Real-Life Examples)
*********************************************
‚û§ YouTube Subscription ‚Üí When a channel uploads a video, all subscribers get notified.
‚û§ Stock Market Apps ‚Üí Investors get alerts when stock price changes.
‚û§ GUI Listeners ‚Üí Button click listeners, keypress listeners.
‚û§ Weather App Updates.

üèóÔ∏è Core Components
********************
‚û§ Subject (Observable)
üëâ Stores the list of observers
üëâ Notifies observers on state change

‚û§ Observer
üëâ Gets updates from the subject
üëâ Defines the update() method

‚û§ Concrete Subject
üëâ Implements maintaining & notifying observers

‚û§ Concrete Observer
üëâ Reacts to subject updates

üß± UML Structure (Simple View)
*********************************
Subject --------> Observer
  |                 ‚Üë
  | notify()        |
  | add/remove      |
ConcreteSubject     |
  | state           |
ConcreteObserver ----

üíª Java Example (Note-Making Friendly)
***************************************
1. Observer Interface
======================
interface Observer {
    void update(String message);
}

2. Subject Interface
======================
interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}

3. Concrete Subject
====================
class YouTubeChannel implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String latestVideo;

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        observers.remove(o);
    }

    @Override
    public void notifyObservers() {
        for (Observer o : observers) {
            o.update(latestVideo);
        }
    }

    public void uploadVideo(String title) {
        this.latestVideo = title;
        notifyObservers();
    }
}

4. Concrete Observer
=====================
class Subscriber implements Observer {
    private String name;

    public Subscriber(String name) {
        this.name = name;
    }

    @Override
    public void update(String video) {
        System.out.println(name + " got notified: New video uploaded -> " + video);
    }
}

5. Test
========
public class Main {
    public static void main(String[] args) {
        YouTubeChannel channel = new YouTubeChannel();

        Observer s1 = new Subscriber("Deepak");
        Observer s2 = new Subscriber("Aman");

        channel.registerObserver(s1);
        channel.registerObserver(s2);

        channel.uploadVideo("Design Patterns in Java!!!");
    }
}

‚≠ê When To Use Observer Pattern
*********************************
‚û§ When multiple objects depend on another object‚Äôs state
‚û§ When you want event-driven architecture
‚û§ When you want loose coupling between broadcaster and listeners

‚úÖ Advantages
**************
‚û§ Loose coupling
‚û§ Easy to add new observers
‚û§ Supports event-driven programming
‚û§ Subject doesn‚Äôt need to know observer details

‚ùå Disadvantages
******************
‚û§ Too many notifications can cause performance overhead
‚û§ Observers might depend on update order
‚û§ Hard to debug due to complex chains

üéØ Interview Questions (Most Asked!)
**************************************
‚û§ What is the observer pattern and where is it used?
‚û§ Difference between Observer and Publish-Subscribe?
üëâ Pub-Sub uses broker; Observer does not.
üëâ In Observer, subject knows observers directly.

‚û§ Is Observer pattern synchronous or asynchronous?
üëâ Classic implementation = synchronous
üëâ Can be async using event queues

‚û§ Which design principle does it follow?
üëâ Follows Open-Closed Principle
üëâ Follows Loose Coupling Principle